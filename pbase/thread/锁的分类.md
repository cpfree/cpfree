# 🔒分类

1. 乐观锁/悲观锁
2. 独享锁/共享锁
3. 互斥锁/读写锁
4. 可重入锁
5. 公平锁/非公平锁
6. 分段锁
7. 偏向锁/轻量级锁/重量级锁
8. 自旋锁

## 概念锁

并不是特指某类型的锁，是人们定义出来的概念或思想。

### 乐观锁/悲观锁

- 乐观锁：就是想法很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。

| -      | 适合情况 | 好处                                       | 举例                                                                  |
| ------ | -------- | ------------------------------------------ | --------------------------------------------------------------------- |
| 乐观锁 | 读多写少 | 读多写少的场景，不加锁会带来大量的性能提升 | CAS(Compare and Swap), java.util.concurrent.atomic 包下面的原子变量类 |
| 悲观锁 | 多写     | 严谨                                       | synchronized,                                                         |

### 乐观锁实现方式

1.  CAS 操作
    CAS(Compare and Swap)，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
    CAS 操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B，否则处理器不做任何操作。

   > CAS 会遇到一个ABA问题, 可以视情况添加版本号.

2.  数据版本机制

    实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例。
    版本号方式：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

    > 如数据库更新数据的时候, 更新一条数据都会将数据的事物 id 或者说版本 id + 1, 当然更新操作是原子性的.

### 悲观锁实现方式

   悲观锁认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。

   在对任意记录进行修改前，先尝试为该记录加上 **排他锁(exclusive locking)**.

   悲观锁就是我们最常见到的🔒.

## 独享锁/共享锁

   独享锁: 又称排它锁, 是指该锁一次只能被一个线程所持有。

   共享锁: 是指该锁可被多个线程所持有。

   对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。

   读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

   独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

   对于Synchronized而言，当然是独享锁。

## 互斥锁/读写锁

   上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

   互斥锁在Java中的具体实现就是ReentrantLock。

   读写锁在Java中的具体实现就是ReadWriteLock。

## 可重入锁

   一个线程可以多次获取同一把锁, 

   可重入锁的一个好处是可一定程度避免死锁。

## 公平锁/非公平锁

   公平锁: 多个线程按照申请锁的顺序来获取锁。

   非公平锁: 多个线程获取锁的顺序并不是按照申请锁的顺序。

   对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

   对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

## 分段锁

   分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

   典型案例: ConcurrentHashMap 的 Segment 设计

##  偏向锁/轻量级锁/重量级锁

   这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

   偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

   轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

   重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。

## 自旋锁

   在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

