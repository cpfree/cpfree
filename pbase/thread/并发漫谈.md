# 并发

## tip

1. JMM 中的变量并不是只有在变量写入的时候, 变量才会由`线程内存`转移到`主内存`
   例如在一次 sleep 过程中, 线程也可能会重新刷新内存, sleep 里面有 yeild(), 涉及到`线程的上下文切换`, 会重新加载内存.

   `System.out.println()`里面涉及到 IO 操作, IO 操作里面涉及到 synchronized.

2. JVM 里面的线程内存和 CPU 的多线程模型是不一样的, 不是一一匹配的, 在 JVM 运行过程中, 可能会有内存的迁移问题.

#### Java锁消除和锁粗化

1. 锁粗化

   > <https://blog.csdn.net/qq_26222859/article/details/80546917>

   锁粗化就是把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。

   为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但是大某些情况下，一个程序对同一个锁不间断、高频地请求、同步与释放，会消耗掉一定的系统资源，因为锁的讲求、同步与释放本身会带来性能损耗，这样高频的锁请求就反而不利于系统性能的优化了，虽然单次同步操作的时间可能很短。这个时候jvm就会有一个锁粗化的优化.

2. 锁消除

   JVM 中 JIT 编译 会消除掉没有必要的锁.
