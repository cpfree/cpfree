# 通信协议

> destination
> 1. 一个Http请求流程是什么
> 2. tcp 三次握手有什么必要, 两次行不行
> 3. 为什么连接的时候是三次握手，关闭的时候却是四次
> 4. TCP 和 UDP相关介绍, 以及它们的优缺点

[TOC]

## TCP 和 UDP 协议

TCP 和 UDP 是两种最为著名的传输层协议，他们都是使用 IP 作为网络层协议。

TCP/IP
   TCP 协议能够检测和恢复 IP 层提供的主机到主机的通信中可能发生的报文丢失、重复及其他错误。TCP 提供了一个可信赖的字节流通道，这样应用程序就不需要考虑这些问题。同时，TCP 协议是一种面向连接的协议，在使用 TCP进行通信之前，两个应用程序之间需要建立一个 TCP 连接，而这个连接又涉及到两台电脑需要完成握手消息的交换。

UDP/IP
   UDP 协议不会对 IP 层产生的错误进行修复，而是简单的扩展了 IP 协议“尽力而为”的数据报文服务，使他能够在应用程序之间工作，而不是在主机之间工作，因此使用 UDP协议必须要考虑到报文丢失，顺序混乱的问题

   1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
   2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
   Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
   3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
   4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
   5、TCP对系统资源要求较多，UDP对系统资源要求较少。

## TCP 是如何做到可靠传输的？

### 三次握手

### 四次挥手

## Http

### Http 协议

HTTP 协议是无状态的，什么是无状态呢？就是说 HTTP 协议本身不会对请求和响应之间的通信状态做保存。

### cookie实现有状态的Http协议

Http 协议中引入了 cookie 技术，用来解决 http 协议无状态的问题。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态；Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。在基于 tomcat 这类的 jsp/servlet 容器中，会提供 session 这样的机制来保存服务端的对象状态。那么整个状态协议的流程就是这样的

### 一个 http 请求过程

通信机制

   当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息
   当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用
   > http请求报文经过传输层 增加 Tcp 头, 数据经过 网络层, 增加Ip地址头, 经过数据链路层, 增加mac地址头
   > 收到数据后 数据经过数据链路层取mac地址确定是否数据是否是发给当前主机的, 经过网络层判断Ip地址, 判断是否是当前地址.
   >
   > ip地址用于确定传输目的地, mac 地址用于认证主机身份.

请求过程

   1. TCP 三次握手
   2. web浏览器想web服务器发送请求命令
   3. web浏览器发送请求头信息, 之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
   4. Web服务器应答请求命令 HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。
   5. Web服务器应答请求头信息, 它会发送一个空白行来表示头信息的发送到此为结束
   6. Web服务器向浏览器发送数据, 以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。
   7. TCP 四次挥手

### Http 方法

method | means
-|-
POST    | 一般用户客户端传输一个实体给到服务端，让服务端去保存（一般用于创建操作）
DELETE  | 客户端发起一个 Delete 请求要求服务端把某个数据删除（一般用于删除操作）
PUT     | 向服务器发送数据，一般用于更新数据的操作
GET     | 一般是用于客户端发送一个 URI 地址去获取服务端的资源（一般用于查询操作）
HEAD    | 用于向服务端发起一个查询请求获取 head 信息，比如获取 index.html 的有效性、最近更新时间等。
OPTIONS | 查询指定 URI 支持的方法类型（get/post）
http1.1 还支持 trace(追踪路径)和 connect 方法类型

### HTTP 协议的缺陷

1. 通信过程中是使用明文，内容可能会被窃听
2. 不验证通信双方的身份
3. 无法验证报文的完整性，报文可能被篡改

### HTTPS

HTTPS 简介
由于 HTTP 协议通信的不安全性，所以人们为了防止信息在传输过程中遭到泄漏或者篡改，就想出来对传输通道进行加密的方式 https。
https 相对于Http来说在 tcp 协议层之上增加了一层 SSL（Secure Socket Layer，安全层）或者 TLS（Transport Layer Security） 安全层传输协议组合使用用于构
造加密通道；

### HTTPS 流程

1. 客户端发起请求(Client Hello 包)
   a) 三次握手，建立 TCP 连接
   b) 支持的协议版本(TLS/SSL)
   c) 客户端生成的随机数 client.random，后续用于生成“对话密钥”
   d) 客户端支持的加密算法
   e) sessionid，用于保持同一个会话（如果客户端与服务器费尽周折建立了一个 HTTPS 链接，刚建完就断了，也太可惜）
2. 服务端收到请求，然后响应（Server Hello）
   a) 确认加密通道协议版本
   b) 服务端生成的随机数 server.random，后续用于生成“对话密钥”
   c) 确认使用的加密算法（用于后续的握手消息进行签名防止篡改）
   d) 服务器证书（CA 机构颁发给服务端的证书）
3. 客户端收到证书进行验证
   a) 验证证书是否是上级 CA 签发的, 在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信
   b) 服务端返回的证书中会包含证书的有效期，可以通过失效日期来验证 证书是否过期
   c) 验证证书是否被吊销了
   d) 前面我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名证书里的签名算法字段 sha256RSA 表示 CA 机构使用 sha256对证书进行摘要，然后使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。
   e) 浏览器使用内置在操作系统上的CA机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的机构颁发。验签之后得知 CA 机构使用 sha256 进行证书摘要，然后客户端再使用sha256 对证书内容进行一次摘要，如果得到的值和服务端返回的证书验签之后的摘要相同，表示证书没有被修改过
   f) 验证通过后，就会显示绿色的安全字样
   g) 客户端生成随机数，验证通过之后，客户端会生成一个随机数pre-master secret，客户端根据之前的： Client.random +sever.random + pre-master 生成对称密钥然后使用证书中的公钥进行加密，同时利用前面协商好的加密算法，将握手消息取HASH 值，然后用“随机数加密“握手消息+握手消息 HASH 值（签名）”然后传递给服务器端；(在这里之所以要取握手消息的 HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。)
4. 服务端接收随机数
   a) 服务端收到客户端的加密数据以后，用自己的私钥对密文进行解密。然后得到 client.random/server.random/pre-master secret. ,再用随机数密码 解密 握手消息与 HASH 值，并与传过来的HASH 值做对比确认是否一致。
   b) 然后用随机密码加密一段握手消息(握手消息+握手消息的HASH 值 )给客户端
5. 客户端接收消息
   a) 客户端用随机数解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，
   b) 之后所有的通信数据将由之前交互过程中生成的 pre mastersecret / client.random/server.random 通过算法得出 sessionKey，作为后续交互过程中的对称密钥