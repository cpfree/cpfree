## 设计模式分类

### 原来的设计模式分类

结构性设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式

行为型模式特别关注对象之间的通信

责任链模式（Chain of Responsibility Pattern）
命令模式（Command Pattern）
解释器模式（Interpreter Pattern）
迭代器模式（Iterator Pattern）
中介者模式（Mediator Pattern）
备忘录模式（Memento Pattern）
观察者模式（Observer Pattern）
状态模式（State Pattern）
空对象模式（Null Object Pattern）
策略模式（Strategy Pattern）
模板模式（Template Pattern）
访问者模式（Visitor Pattern）

原来分类不太适合现在

例如 中介者模式, 观察者模式, 访问者模式全部 打到行为型里面去了.

### 对象创建

1. 单例
2. 多例(工厂)
3. 建造者
4. 原型模式

### 对象管理 extends 对象创建

享元模式偏重于: 对象共享使用, 偏重于节省空间.
池模式偏重于: 对象重复使用, 偏重于资源.

1. 池模式: 复用
2. 享元模式: 共享
3. 
4. SpringBean管理: 管理

### 半基础对象关系型

1. 代理
   1. 动态代理
   2. 静态代理
   3. 闭包代理
2. 装饰模式
3. 外包
4. 委派
   1. 模板+外包

### 抽象关系型

1. 策略模式
2. SPI
3. 桥接模式
4. 访问者模式

### 复杂结构性

1. 中介者模式
2. 责任链模式
3. 组合模式
4. 门面模式

### 数据处理型

1. 命令模式
2. 状态模式
3. 解释器模式

### 事件监听传播

1. 接口回调方法
   简单的接口回调, 不成模式
   也可以理解为一个简单的观察者模式.

2. 观察者模式
   简单来说就是有消息主体 `Subject`, 以及它的观察者 `Observer`, 消息主题里面配置或在外部配置一个观察者列表.
   假如一个Client对象想要观察`Subject`里面的事件, 就基于`Observer`去实现一个`ClientObserver`, `ClientObserver`里面定义一下收到观察者事件后对Client的处理逻辑, 之后将`ClientObserver`添加到 观察者列表里面, 
   这样, 每次`Subject`里面有消息的时候就会遍历观察者列表, 去执行其中的方法, 带动Client的变化.
   特点: 每次驱动事件, 都是由`Subject`驱动的, Client 实现对 `Subject`之后就不需要有其它任何的处理逻辑了.

3. 发布订阅

   一般来说都是跨服务, 跨模块的.
   是异步的, 独立的, 带有中心管理的.
   发布方相对独立, 发布方只需要往外提供`订阅/注册/退订`等功能, 之后每次有消息往订阅列表循环发送数据即可, 不再驱动订阅方做处理.
   订阅方需要自己去订阅消息, 和接受消息的处理逻辑, 至于接收到消息处理不处理, 那也是订阅方自己的事情. 
   > 观察者模式此处是

4. 消息监听器
   消息监听就是偏向对象功能的说法了.
   简单来说就是在`被观察者模块或者是发布方已经写好了的前提下, 只考虑添加订阅方或者是观察者之类的`.

   - ui 消息监听
      一个事物去监听别的事件, 监听到了别的事件之后, 去触发添加的监听器事件.
      例如一个按钮, 通过主动对一个按钮添加消息监听器, 每当按钮被点击的时候去触发消息监听器.
      特点: 相对于观察者模式来说可以没有client, 只是消息监听.
         只涉及到观察者设计, 不涉及被观察者.

   - socket消息监听
      妥妥一个发布订阅的客户端模块.
      特点: 相对于发布订阅模式来说只是一个订阅方, 不涉及发布方.

---

接口回调, 观察者一般来说是同步的
消息监听, 一般是比较功能的说法, 监听的一般都是就是`消息`, `事件`.
发布订阅一般都是带中心, 跨服务跨模块级别的.

### 数据结构型

1. 适配器模式
2. 迭代器模式
3. 备忘录模式

### 解决复杂性

1. 中介者(网状变星状)
2. 发布订阅(异步解耦)
3. 组合模式
4. 信息映射
   1. 配置+信息:命令模式
   2. 配置+信息:解释器
   3. 文件和对象的映射
   4. 将一切复杂的关系转换为数据或配置, 在数据和配置的层面进行处理(仅仅处理内容), 而不是使用写死的代码结构(有代码的话就是**行为和内容**不分离).
5. 课题分离
   1. 行为和ui和内容
![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644475776701.png)
