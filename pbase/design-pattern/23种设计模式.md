---
keys: 
type: copy,blog,trim
url: <>
id: 220125-142921
---

# 23种设计模式

## 模板方法模式

- 优点:

   - 封装不变部分，扩展可变部分
      把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。
   - 提取公共部分代码，便于维护
      我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！
   - 行为由父类控制，子类实现
      基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。

- 缺点:

   抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是**子类对父类产生了影响**.
   复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。

- 模板方法模式的使用场景
   ● 多个子类有公有的方法，并且逻辑基本相同时。
   ● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
   ● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。

> 例如一辆车需要启动, 鸣喇叭, 跑几个步骤, 但是有几辆车不需要鸣喇叭, 可以添加一个 `isAlarm` 的实现方法, 变成下面这样

```java
function(){
   // 启动
   car.start();
   if (isAlarm()) {
      car.alarm();
   }
   car.run();
}
```

- 模板方法模式使用

   1. 子类可以调用父类方法, 但是父类最好不要调用除模板方法以外的其它方法.


### 建造者模式

- 建造者模式的优点
   ● 封装性
      使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。
   ● 建造者独立，容易扩展
      BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。
   ● 便于控制细节风险
      由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

- 建造者模式的使用场景
   ● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
   ● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
   ● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
   ● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。

- 建造者模式的注意事项
   建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。



> 工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的
> 建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同.
> 建造者模式里面一般有模板方法模式.

### 代理模式

- 普通代理
- 强制代理: 强制代理在设计模式中比较另类，为什么这么说呢？一般的思维都是通过代理找到真实的角色，但是强制代理却是要“强制”，你必须通过真实角色查找到代理角色，否则你不能访问。甭管你是通过代理类还是通过直接new一个主题角色类，都不能访问，只有通过真实角色指定的代理类才可以访问，也就是说由真实角色管理代理角色。这么说吧，高层模块new了一个真实角色的对象，返回的却是代理角色，这就好比是你和一个明星比较熟，相互认识，有件事情你需要向她确认一下，于是你就直接拨通了明星的电话：
- 动态代理: AOP

代理模式一般都会有自己的个性.


### 原型模式

原型模式的核心是一个 clone 方法, 使用clone方法不会调用构造函数, 使得复制一个新的原型非常快.

**好处是 性能优良, 优点是减少了约束**, 使用clone方法不会调用构造函数.

缺点也是减少了约束, 使用clone方法不会调用构造函数.

- 使用场景

   - 资源优化的场景
   - 一个对象多个修改者, 修改者可以不去修改原对象, 而是clone一个原型, 被修改者使用.

- 注意事项

   - clone 不会调用构造函数
   - 深拷贝和浅拷贝问题.
   - final 关键字的 成员变量无法进行 `clone()` 拷贝, 调用 `clone()`方法, 遇到 final 会报错.


### 中介者模式

用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

简单来说增加一个中介对象, 将对象之间的交互从网状变成星状.

优点
   - 降低耦合, 提高扩展性

缺点
   - 中介类变得复杂.

一般出现类之间的网状结构的时候, 再考虑使用中介模式, 对象之间的依赖关系是必然存在的, 如果某个类和其他类没有任何相互依赖的关系，那这个类就是一个“孤岛”，在项目中就没有存在的必要了！

注意: 

   搞清楚中介和代理的区别

实际应用

   - MVC模式中的 C(控制器) 就是中介者模式
   - 调度中心.
   - 媒体网关(不是前后端): 两个用户发送消息, 会先将消息发送给服务器, 再由服务器进行广播通知, 服务器就是一个中介.


## 找工作

1. web 上面已经没有什么困难的技术, 甚至连架构也有标准化的模板

2. 一个公司的

## 命令模式

将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

优点:
   1. 类间解耦合, 发送命令方和接受命令方不需要知道对方的存在.

> 命令模式一般使用场景非常多, **命令模式一般适用于异步消息**. MQ异步消息, 线程池队列, 请求和相应都包含命令模式.

实例:

   1. 报文请求
   2. 请求 request 和 响应 response
   3. GUI开发的时候的一个按钮点击.
   4. MQ消息

## 责任链模式

定义是: 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

简单来说就是将复杂的责任分配, 变成一个链状结构.

如果不使用责任链, 可能就是需要一个分配器, 判断对象状态, 看下对象应该由那些类处理, 之后将对象分配给处理类, 但是有了责任链, 就是由处理类判断对象是否应该由自己去处理, 并判断是否应该继续往下发.

- 责任链模式的优点
   将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌，两者解耦，提高系统的灵活性。

- 责任链模式的缺点
   - 性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。
   - 调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。

- 责任链模式的注意事项
   链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。

## 装饰模式

定义: 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。

装饰模式是对类的功能的**增强或者减弱**, 着重功能的变化.

优点:
   - 解耦合, 灵活, 可以动态添加功能.
   - 扩展性非常好。
   - 装饰模式是对继承的有力补充。

缺点:
   多层装饰, 会导致比继承更加复杂.


## 策略模式

定义: Define a family of algorithms,encapsulate each one,and make them interchangeable.（定义一组算法，**将每个算法都封装起来**，并且使它们之间可以互换。）

类里面没有算法, 只调用抽象, 传入一个对抽象的实现算法, 类调用这个算法.

优点: 
   - 避免if else 多重判断
   - 算法可以自由切换
   - SPI机制
   - 扩展性好

缺点:
   - 增加了策略类的数量
   - 所有策略都需要向外暴漏

## 适配器模式

定义: Define a family of algorithms,encapsulate each one,and make them interchangeable.（定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。）

优点:
   - 增加类的透明性
   - 不需要改变原有类

适配器模式是一个补偿模式，或者说是一个“补救”模式，通常用来解决接口不相容的问题，

一般来说, 设计开发阶段不需要考虑适配器, 一般是扩展的时候才考虑适配器, 或者和别的系统对接的时候.

## 迭代器模式

Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.（它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。）

简单来说就是针对容器中对象的访问, 一般来说, 大部分高级语言都已经对容器进行了较好的迭代器实现, 我们一般不会考虑它.

Java开发，尽量不要自己写迭代器模式！省省吧，使用Java提供的Iterator一般就能满足你的要求了。

## 组合模式

组合模式(Composite Pattern)也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系，其定义如下：

Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。）

优点: 
   - 高层模块调用简单
      一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。
   - 节点自由增加
      使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。

使用场景

   - 树形菜单, 文件夹.
   - 一个整体中能独立出来的部分模块或功能的场景.

## 观察者

观察者模式（Observer Pattern）也叫做发布订阅模式（Publish/subscribe）,它是一个在项目中经常使用的模式，其定义如下：

`Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically`.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）

观察者模式也叫做发布/订阅模型（Publish/Subscribe）

观察者模式一般是程序内部模式, 发布订阅模式一般涉及到程序或服务之间

## 门面模式

Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.（要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。）

实现实例:

   系统内部和系统对外开放的API接口.
   类内部复杂的结构, 和对外暴露的public方法.
   多个类复杂的结构, 和对外提供的方便的使用方法.

## 备忘录模式

使用实例

   1. 保存和恢复数据的场景
   2. `CTRL+Z`
   3. 事务管理中的`ROLL BACK`

## 访问者模式

定义: 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

   一个员工类, 一个领导类, 领导视察员工, 改变为 员工去实现一个视察接口, 员工实现一个视察的方法, 方便领导视察.

优点: 

   1. 员工种类可能有很多, 使用访问者模式比较灵活
   2. 符合单一职责原则, 领导访问什么应该由员工来定义, 而不是领导.
   3. 员工不必向外部暴漏属性和方法, 员工只需要提供一个能够让领导进来的大门, 而不是需要将房间里的东西一个个搬出去让别人看.

缺点:
   1. 需要对访问者公布细节
   2. 元素变更困难
   3. 违背依赖倒置原则.
   4. 多个访问者需要实现多个接口.

使用实例

   1. 统计功能
   2. 员工数据检查
   3. 统一的报表运算、UI展现

## 状态模式

类里面有所有的处理逻辑, 传入状态, 类根据状态去调用不同的行为

状态模式的一个特征是 **行为根据状态而变**

   只要状态变了, 行为就会改变.
   一般除了状态本身以外, 其它的都是无状态的(不存储数据的).
   这个状态是给内部方法看的.

> 线程里面的线程状态不是状态模式, 例如你强行更改状态的话, 会导致线程异常. 线程里面的状态主要是给外部看的, 是所谓的`行为驱动状态`, 因此他不是状态模式. 同时工作流的状态也不是状态模式.

使用实例:

   1. 对文档的解析, 对不同的内容定义不同的状态, 然后根据不同的状态定义不同的处理方法.
   2. 条件, 分支判断的替代场景.

## 解释器模式

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

解释器模式是对状态模式的高级升华版.

状态模式一般就几种状态, 解释器模式一般是一种复杂的对象, 或者语言.

## 享元模式

享元模式（Flyweight Pattern）是池技术的重要实现方式，其定义如下：Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度的对象。）

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

意图：运用共享技术有效地支持大量细粒度的对象。

主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。

注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

1. 无状态的享元: 线程池, 棋子类, 坐标对象.
2. 内部有状态的享元: StringBuilder 用后或用前, 将其的长度重置为0

## 实现

五子棋游戏的位置对象和棋子对象


## 桥接模式

定义: 将抽象和实现解耦，使得两者可以独立地变化。

调用者, 被调用者, 甚至多个被调用者都进行抽象, 之后通过抽象对象之间的桥接, 达成对象之间的桥接
