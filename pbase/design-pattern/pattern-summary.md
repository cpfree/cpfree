---
keys: 
type: copy,blog,trim
url: <>
id: 220124-124828
---

# pattern-summary

## 设计模式分类

> 设计模式主要分为三种类型：创建型、结构型和行为型三种

### 创建型

创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。

创建型（5 种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

1. 简单工厂模式 严格意义来说，不属于 GOF23 种设计模式
2. 工厂方法模式 只对结果负责，封装创建过程
3. 抽象工厂模式
4. 原型模式 拔一根猴毛，吹出千万个。用于创建重复的对象，同时又能保证性能
5. 单例模式 单例和原型是互斥的 保证独一无二。
6. 建造者模式

### 结构型

结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）封装性（适配器，桥接）

结构型（7 种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

1. 代理模式（静态代理、动态代理） 找人办事，增强职责。
2. 适配器模式 兼容转换头。
3. 装饰器模式 包装，同宗同源。
4. 桥接模式
5. 享元模式
6. 外观（门面）模式
7. 组合模式

### 行为型

行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式 1.行为模式使用继承机制在类间分派行为 2.行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。

行为型（11 种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

模板模式 流程标准化，自己实现定制。
策略模式 用户选择，结果统一。
责任链模式  
命令模式  
迭代器模式 不常用
状态模式  
观察者模式 任务完成时通知。
中介者模式  
备忘录模式  
解释器模式  
访问者模式  

### 差异汇总

### 创建类模式

1. 单例模式和工厂模式：

    在实际开发中，一般会把工厂类写成单例模式；

2. 工厂方法模式VS建造者模式

   工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是**部件构建的过程**，旨在通过一步一步地精确构造创建出一个复杂的对象。

3. 抽象工厂模式VS建造者模式

   抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

### 其它

1. 策略模式 & 工厂模式：

   - 策略模式属于行为模式，工厂模式属于创建型模式；
   - 工厂模式在于封装对象的创建，策略模式在于接收工厂创建的对象，从而实现不同的行为。

2. 策略模式 & 委派模式：

   - 策略模式是委派模式的一种内部实现形式，策略模式关注的结果是能否相互贴换。
   - 委派模式不是GOF23种设计模式，更多关注分发，调度的过程。

3. 策略模式 & 桥梁模式

   一维和二维(甚至多维)

4. 策略模式 & 状态模式

   策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；

   而状态模式封装的是不同的状态，以达到状态切换行为随之发生改变的目的。

   策略模式一般内部没有算法, 算法由外部供给

   状态模式一般内部有全部算法, 外部只需要提供状态.

5. 策略模式 & 模板模式：

   - 策略模式和模板模式都是行为模式；
   - 策略模式与模板模式都有封装算法，策略模式重点是不同的算法之间可以相互贴换，模板模式重点是定义一套流程。
   - 策略模式可以改变算法流程，可以替代代码中的if...else...分支；模板模式不能改变算法的流程。

---

6. 装饰器模式和静态代理：

   - 装饰器模式强调给对象动态添加方法，而代理更注重控制对 对象的访问。
   - 代理模式和装饰器模式都持有对方的引用，但逻辑处理重心不一样。

7. 装饰模式 & 代理模式

   代理模式着重对代理过程的控制，而装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化

   代理模式是对象之间的关系, 装饰模式是对对象功能的装饰, 是对象与功能之间的关系.

8. 装饰模式和适配器模式

   - 装饰者模式和适配器模式都是属于包装器模式；
   - 装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配器和被适配者可以实现不同的接口。

9. 装饰模式VS适配器模式

   装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。

---

1. 命令模式VS策略模式

   策略模式的意图是封装算法，算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；

   而命令模式则是对动作的解耦，把一个动作的执行分为执行对象（接收者角色）、执行行为（命令角色），让两者相互独立而不相互影响。

2. 观察者模式VS责任链模式

   在观察者模式中也提到了触发链（也叫做观察者链）的问题，一个具体的角色既可以是观察者，也可以是被观察者，这样就形成了一个观察者链。

   这与责任链模式非常类似，它们都实现了事务的链条化处理，那什么是触发链？你还是在课堂上睡觉，还是打鼾声音太大，老师火了，但是老师掏出个扩音器来讲课，于是你睡不着了，同时其他同学的耳朵遭殃了，这就是触发链，其中老师既是观察者（相对你）也是被观察者（相对其他同学），事件从“你睡觉”到老师这里转化为“扩音器放大声音”，这也是一个链条结构，但是链结构中传递的事件改变了。

3. 门面模式VS中介者模式

   门面模式侧重的是: 整合内部, 向外部暴漏接口
   中介者模式侧重的是: 对内部类之间的结构梳理, 将网状结构转变成星型结构.
