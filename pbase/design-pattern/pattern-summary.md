# pattern-summary

> 参考自: 《设计模式之禅(第二版)》, 菜鸟教程

## 设计模式六大原则

> 所有的原则都是为了让我们写出更高效、更易于扩展、更便于维护和更稳定的代码，我们应该要根据具体的情况去取舍，而不能为了用设计原则而用，这样可能会带来别的问题。

1. 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

   定义：Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件、模块和类应该对扩展开放，对修改关闭。）

   > 开闭原则是 java 世界里最基础的设计原则，**依赖倒置原则，单一职责原则，迪米特原则，接口隔离原则和里氏替换原则**都是开闭原则的具体表现形式，它指导我们建立一个稳定的、灵活的系统。
   > 我们在程序设计阶段，一旦设计好了接口，就不应该再去修改它，因为你每次修改都会影响系统的稳定性，你修改了这个接口，就会影响其他的实现类，那么如果之前已经测试过的代码就需要重新再测试一遍，这样对整个项目周期来说，影响是非常大的。所以我们应该尽量做到只让他扩展，因为扩展你不需要对之前的代码再进行测试了，只需要测试新扩展的部分即可。

2. 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责**一个功能领域**中的相应职责，**或者**可以定义为：就一个类而言，**应该只有一个引起它变化的原因**。
   advantage : 类的复杂度降低, 可读性和可维护性提高, 变更引起风险降低.
   disadvantage : 类和接口的数量增加, 结构变得复杂.

   > 我们在设计的时候，应该尽可量做到职责单一。实现的时候我们要让它只负责一个任务，我这个方法的逻辑修改了，不应该影响其他方法的逻辑。听起来很简单，但是如何单一是一个饱受争议的。往往我们看待事物是有不同的角度，从这个方向看，它满足了单一，而从另一个方向看却又不那么单一，所以，如何设计还是需要考虑取舍和平衡。建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

3. 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

   > 我们在写程序的时候，如果使用的是其基类，那么就可以通过它的子类来替换，同时，结果是不会改变的。

4. 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
   实现模块之间的松耦合

5. 接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

6. 迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

   > 比如说，老师让班长统计一下女生的人数。老师下达命令给班长，班长去统计女生人数，老师并不需要知道女生的情况，而是只需要下达这个命令，而班长才是实际和女生打交道的那个"朋友"。那么我们在实现的时候只需要在班长这个类里建立起和女生的关系就好了，而不需要在老师类里，建立女生的关系。

7. 合成复用原则：

   > 尽量使用组合和聚合的方式，而不是继承的方式。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。继承的话会比较臃肿，因为继承的话就会拥有父类的所有方法，每次执行都要先去父类那边转一圈，在回到子类，能用组合的时候就用组合。

## 设计模式分类

> 设计模式主要分为三种类型：创建型、结构型和行为型三种

### 创建型

创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。

创建型（5 种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

1. 简单工厂模式 严格意义来说，不属于 GOF23 种设计模式
2. 工厂方法模式 只对结果负责，封装创建过程
3. 抽象工厂模式
4. 原型模式 拔一根猴毛，吹出千万个。用于创建重复的对象，同时又能保证性能
5. 单例模式 单例和原型是互斥的 保证独一无二。
6. 建造者模式

### 结构型

结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）封装性（适配器，桥接）

结构型（7 种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

1. 代理模式（静态代理、动态代理） 找人办事，增强职责。
2. 适配器模式 兼容转换头。
3. 装饰器模式 包装，同宗同源。
4. 桥接模式
5. 享元模式
6. 外观（门面）模式
7. 组合模式

### 行为型

行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式 1.行为模式使用继承机制在类间分派行为 2.行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。

行为型（11 种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

模板模式 流程标准化，自己实现定制。
策略模式 用户选择，结果统一。
责任链模式  
命令模式  
迭代器模式 不常用
状态模式  
观察者模式 任务完成时通知。
中介者模式  
备忘录模式  
解释器模式  
访问者模式  

### 差异汇总

1、单例模式和工厂模式：

    在实际开发中，一般会把工厂类写成单例模式；

2、策略模式和工厂模式：

    1）策略模式属于行为模式，工厂模式属于创建型模式；
    2）工厂模式在于封装对象的创建，策略模式在于接收工厂创建的对象，从而实现不同的行为。

3、策略模式和委派模式：

    1）策略模式是委派模式的一种内部实现形式，策略模式关注的结果是能否相互贴换。
    2）委派模式不是GOF23种设计模式，更多关注分发，调度的过程。

4、策略模式和模板模式：

    1）策略模式和模板模式都是行为模式；
    2）策略模式与模板模式都有封装算法，策略模式重点是不同的算法之间可以相互贴换，模板模式重点是定义一套流程。
    3）策略模式可以改变算法流程，可以替代代码中的if...else...分支；模板模式不能改变算法的流程。

5、装饰器模式和静态代理：

    1）装饰器模式强调给对象动态添加方法，而代理更注重控制对 对象的访问。
    2）代理模式和装饰器模式都持有对方的引用，但逻辑处理重心不一样。

6、装饰器模式和适配器模式：

    1）装饰者模式和适配器模式都是属于包装器模式；
    2）装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配器和被适配者可以实现不同的接口。
