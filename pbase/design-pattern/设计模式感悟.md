# 设计模式感悟

如何解决复杂性难题

一个好的复杂性系统, 应该由最简单的内核以及外层的插件, 

一个好的复杂性规模数据, 应该由简单的实体, 组合, 嵌套, 集合而成.

## spring Bean 注入是访问者模式

## 抽象化访问者模式

传统的访问者模式不应该包括Spring Bean注入的, 但是可以把访问者模式再次进行抽象一下, 从思想的角度理解访问者模式, 就可以将Spring Bean注入划归到访问者模式当中去.

### 传统访问者模式简单介绍

定义: 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

   一个员工类, 一个领导类, 领导视察员工, 改变为 员工去实现一个视察接口, 员工实现一个视察的方法, 方便领导视察.

   ```java
   public class JavaCoder extends IClerk{
      //完善业务逻辑
      public void doSomething(){
         //业务处理
      }
      //允许那个访问者访问
      public void accept(IVisitor visitor) {
         visitor.visit(this);
      }
   }
   ```

简单来说, 就是领导里面定义了 `visit(JavaCoder)` 方法, 对JavaCoder里面的属性进行一个个检查, 

---

最开始我想着能不能把 `accept` 方法取出来, 既然很简单, 而且很抽象, 那取出来是不是比较好呢? 后来我发现, 取出来之后就变成桥接模式了(一般来说桥接只是桥接在使用的时候, 仅仅作用两个对象, 而这个桥接了两个维度)

访问者和被访问者都是基于`一个类`实现的(不是多个类).

增加一个领导, 那么员工想要被访问, 就必须更改员工类, 在员工类上面增加方法.

这就是所谓的, 抽象依赖具体, 违背了依赖倒置原则, 此时根本解耦不了, 所以后来又从外面放进去了.

## 访问者模式和桥接模式的区别联系

1. 联系

   桥接模式是将两个事物进行抽象化, 之后在接口或抽象类的层次上对两个事物进行关系的处理, 从而实现具体类之间的隔离和解耦合.

   都是利用抽象和多态完成的.

   而访问者模式可以视为以`桥接模式`为基础的, 访问者和被访问者之间的关系可以很简单, 如下
   
   ```java
   public class JavaCoder extends IClerk{
      //允许那个访问者访问
      public void accept(IVisitor visitor) {
         visitor.visit(this);
      }
   }
   ```

   访问者里面一个重载多个`visit(IClerk)`, 被访问者重载多个 `accept(IVisitor visitor)`, 实际上就是实现了访问者和被访问者的桥接.

2. 区别

   桥接模式比较简单, 侧重于两抽象事务的联结, 但它考虑的仅仅只对两个事物进行连接, 符合依赖倒置原则, 两个事物只要对抽象进行实现就可以了. 也符合开闭原则.
   桥接模式实际上就是定义了一个API契约, 契约允许多对多, 但是真正使用的时候是1对1的.

   访问者模式稍加复杂, 侧重于两抽象事务的联结, 但它考虑的却是两个维度事务的联结映射, 两个维度进行连接映射的化, 难以满足依赖导致原则, 映射的时候两个维度均需要根据具体的事物进行多态的调用, 不符合开闭原则.
   访问者模式相当于契约是多对多的, 实现也是多对对的.

   > 硬币分币器分硬币.

### 访问者模式应用场景

访问者模式更适合解决去解决程序的`复杂性`, 是一种集中规整模式，特别适用于大规模重构的项目, 通过访问者模式可以很容易把一些功能进行梳理.

   如中介者模式里面的中介类在规模比较大的时候就会显得非常复杂, 此时就可以使用访问者模式.
   在不考虑结构, 只考虑思想的化, Spring Bean 注入实际上就可以从思想上理解为访问者模式.
   达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他模式混编建立一套自己的过滤器或者拦截器




