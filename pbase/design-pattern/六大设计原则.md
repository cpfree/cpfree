# 设计模式六大原则

> 参考自:《设计模式之禅(第二版)》

## 设计原则综述

软件设计最大的难题就是应对需求的变化，但是纷繁复杂的需求变化又是不可预料的。我们要为不可预料的事情做好准备，这本身就是一件非常痛苦的事情，但是大师们还是给我们提出了非常好的6大设计原则以及23个设计模式来“封装”未来的变化，我们在前5章中讲过如下设计原则。

● Single Responsibility Principle：单一职责原则(单一业务)
● Open Closed Principle：开闭原则(用扩展拥抱变化)
● Liskov Substitution Principle：里氏替换原则(实现优雅继承)
● Law of Demeter：迪米特法则(最少知道原则, 类间解耦)
● Interface Segregation Principle：接口隔离原则(去除冗余接口,最小化接口)
● Dependence Inversion Principle：依赖倒置原则(面向接口编程)

> 把这6个原则的首字母（里氏替换原则和迪米特法则的首字母重复，只取一个）联合起来就是SOLID（solid，稳定的），其代表的含义也就是把这6个原则结合使用的好处：建立稳定、灵活、健壮的设计.

1. 项目规章非常重要
   如果你是一位项目经理或架构师，应尽量让自己的项目成员稳定，稳定后才能建立高效的团队文化，章程是一个团队所有成员共同的知识结晶，也是所有成员必须遵守的约定。优秀的章程能带给项目带来非常多的好处，如提高开发效率、降低缺陷率、提高团队士气、提高技术成员水平，等等。

2. 预知变化
   在实践中过程中，架构师或项目经理一旦发现有发生变化的可能，或者变化曾经发生过，则需要考虑现有的架构是否可以轻松地实现这一变化。架构师设计一套系统不仅要符合现有的需求，还要适应可能发生的变化，这才是一个优良的架构。
   开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”。

3. 依照具体环境, 审时度势

   所有的原则都是为了让我们写出更高效、更易于扩展、更便于维护和更稳定的代码，我们应该要根据具体的情况去取舍，而不能为了用设计原则而用，这样可能会带来别的问题。

   在实际的项目中使用设计原则时需要审时度势，不要抓住一个原则不放，每一个原则的优点都是有限度的，并不是放之四海而皆准的真理，所以别为了遵循一个原则而放弃了一个项目的终极目标：投产上线和盈利。作为一个项目经理或架构师，应该懂得技术只是实现目的的工具，惹恼了顶头上司，设计做得再漂亮，代码写得再完美，项目做得再符合标准，一旦项目亏本，产品投入大于产出，那整体就是扯淡！

## 单一职责原则(Single Responsibility Principle, SRP)

定义

   - 定义1: 一个类只负责一个功能领域中的相应职责.
   - 定义2: 一个类应该**只有一个引起它变化的原因**。

优劣:

   advantage : 类的**复杂度降低导致可读性和可维护性提高**, 同时变更引起风险降低.
   disadvantage : 类和接口的数量增加, 结构变得复杂.

   > 我们在设计的时候，应该尽可量做到职责单一。实现的时候我们要让它只负责一个任务，我这个方法的逻辑修改了，不应该影响其他方法的逻辑。听起来很简单，但是如何单一是一个饱受争议的。往往我们看待事物是有不同的角度，从这个方向看，它满足了单一，而从另一个方向看却又不那么单一，所以，如何设计还是需要考虑取舍和平衡。建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

最佳实践

   对于单一职责原则，我的建议是**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。**

## 里氏代换原则(Liskov Substitution Principle, LSP)

### LSP-漫谈

在面向对象的语言中，继承是必不可少的、非常优秀的语言机制, 但其也有优缺点

   优点: 代码共享(提高重用性, 减少代码量), 代码的扩展性提高, 提高产品的开放性
   缺点: 
      - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
      - 降低代码的灵活性。子类必须拥有父类的属性和方法；
      - 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。

里氏转换原则意义: **为了尽量使用继承的优点, 规避继承的缺点**

### LSP-定义:

   - 定义1: 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
      > If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
   - 定义2: 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。
      > Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）

   > 我们在写程序的时候，如果使用的是其基类，那么就可以通过它的子类来替换，同时，结果是不会改变的。

### LSP-解析

里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

1. 子类必须完全实现父类的方法

   如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
   
2. 子类可以有自己的个性

   > 之类在继承父类的方法时, 可以有自己的个性

3. 覆盖或实现父类的方法时输入参数可以被放大

   Web Service开发就应该知道有一个“契约优先”的原则，也就是先定义出WSDL接口，制定好双方的开发协议，然后再各自实现。里氏替换原则也要求制定一个契约，就是父类或接口，这种设计方法也叫做Design by Contract（契约设计），与里氏替换原则有着异曲同工之妙。契约制定了，也就同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；后置条件就是我执行完了需要反馈，标准是什么。

   与父类的方法名相同，但又不是覆写（Override）父类的方法。你加个@Override试试看，会报错的，为什么呢？方法名虽然相同，但方法的输入参数不同，就不是覆写，那这是什么呢？是重载（Overload）！不用大惊小怪的，不在一个类就不能是重载了？继承是什么意思，子类拥有父类的所有属性和方法，方法名相同，输入参数类型又不相同，当然是重载了。

4. 覆写或实现父类的方法时输出结果可以被缩小

   采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### LSP-最佳实践

尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准

1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法
2. 子类中可以增加自己特有的方法。
3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

## 依赖倒置原则(Dependence Inversion Principle,DIP)

### DIP-定义

High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

翻译过来，包含三层含义：

   - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
   - 抽象不应该依赖细节；
   - 细节应该依赖抽象。

### DIP-解析

依赖倒置原则在Java语言中的表现就是：

   - 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
   - 接口或抽象类不依赖于实现类；
   - 实现类依赖接口或抽象类。

更加精简的定义就是**面向接口编程**——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

> 还可以说成面向抽象编程, 和面向契约编程

DIP目的: 为了协作并行开发时, **解决模块之间的项目依赖关系**

> 依赖
> 
> 对象之间的依赖是可以传递的, 但只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！
> - 构造函数传递依赖对象(构造方法注入)
> - Setter方法传递依赖对象(Set方法注入)
> - 接口声明依赖对象(接口注入)

> 倒置和正置
> 
> 依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑，而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的。

> 依赖倒置原则的优点在小型项目中很难体现出来，例如小于10个人月的项目，使用简单的SSH架构，基本上不费太大力气就可以完成，是否采用依赖倒置原则影响不大。但是，在一个大中型项目中，采用依赖倒置原则有非常多的优点，特别是规避一些非技术因素引起的问题。项目越大，需求变化的概率也越大，通过采用依赖倒置原则设计的接口或抽象类对实现类进行约束，可以减少需求变化引起的工作量剧增的情况。

> 依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭。在项目中，大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。

### DIP-最佳实践

1. 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
   这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。
2. 变量的表面类型尽量是接口或者是抽象类

3. 任何类都不应该从具体类派生
   如果一个项目处于开发状态，确实不应该有从具体类派生出子类的情况，但这也不是绝对的，因为人都是会犯错误的，有时设计缺陷是在所难免的，因此只要不超过两层的继承都是可以忍受的。特别是负责项目维护的同志，基本上可以不考虑这个规则，为什么？维护工作基本上都是进行扩展开发，修复行为，通过一个继承关系，覆写一个方法就可以修正一个很大的Bug，何必去继承最高的基类呢？（当然这种情况尽量发生在不甚了解父类或者无法获得父类代码的情况下。）
4. 尽量不要覆写基类的方法
   如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。
5. 结合里氏替换原则使用
   - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系.
   - 抽象类负责公共构造部分的实现.
   - 实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。

## 接口隔离原则(Interface Segregation Principle, ISP)

使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

### ISP-定义

定义1: Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）
定义2: The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）

### ISP-漫谈

> 把不需要的接口剔除掉，对接口进行细化，只保留必要的接口, 保证其纯洁性；

> **接口隔离原则与单一职责的区别**
>
> 接口隔离原则与单一职责的审视角度是不相同的.
> 单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，
> 而接口隔离原则要求接口的方法尽量少。
> 
> 例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。

### ISP-保证接口的纯洁性

接口隔离原则是对接口进行规范约束，其包含以下4层含义：

1. 接口要尽量小
   
   这是接口隔离原则的核心定义，但是“小”是有限度的，首先就是不能违反单一职责原则.

2. 接口要高内聚

   具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。
   > 什么是高内聚？
   > 
   > 高内聚就是提高接口、类、模块的处理能力，减少对外的交互。
   > 比如你告诉下属“到奥巴马的办公室偷一个×××文件”，然后听到下属用坚定的口吻回答你：“是，保证完成任务！”一个月后，你的下属还真的把×××文件放到你的办公桌上了，这种不讲任何条件、立刻完成任务的行为就是高内聚的表现。
   
3. 定制服务
   
   为不同类型的客户端或服务定义不同的接口.
   > 一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务，什么是定制服务？定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法，这是什么意思？我们举个例子来说明，比如我们开发了一个图书管理系统，其中有一个查询接口，方便管理员查询图书，其类图如图4-4所示。

4. 接口设计是有限度的

   > 接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断呢？根据经验和常识判断，没有一个固化或可测量的标准。

### ISP-最佳实践

1. 一个接口只服务于一个子模块或业务逻辑；
2. 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；
3. 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；
4. 了解环境，拒绝盲从。

> 一个接口一个方法，保证绝对符合接口隔离原则（有可能不符合单一职责原则），但是复杂性会很高.
> 根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，接口粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险.

## 迪米特法则(Law of Demeter, LoD)

> 迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）

> 核心是: 类间解耦

### LOD-定义

一个软件实体应当尽可能少地与其他实体发生相互作用。

> 你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

> 比如说，老师让班长统计一下女生的人数。老师下达命令给班长，班长去统计女生人数，老师并不需要知道女生的情况，而是只需要下达这个命令，而班长才是实际和女生打交道的那个"朋友"。那么我们在实现的时候只需要在班长这个类里建立起和女生的关系就好了，而不需要在老师类里，建立女生的关系。

1. 只和朋友交流
2. 适当调整朋友间的距离.
3. 是自己的就是自己的
   > 在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？
   > 你可以坚持这样一个原则：如果一个方法放在本类中，**既不增加类间关系，也对本类不产生负面影响**，那就放置在本类中。

4. 谨慎使用 Serializable, 可以定义序列号

   > 弊端: 一个实现类或接口在客户端已经变更了，而服务器端却没有同步更新，容易爆 NotSerializableException异常。

### LOD-最佳实践

迪米特法则的核心观念就是类间解耦.

优点: 提高了类的复用率。
缺点: 产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。

读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。

## 开闭原则(Open-Closed Principle, OCP)

> 通过扩展实现新的需求和变化, 完成业务变化对系统的最小化开发

### OCP-定义

Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）

一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

### OCP-漫谈

开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

在一个基本稳定的项目中, 放弃修改历史的想法吧，一个项目的基本路径应该是这样的：项目开发、重构、测试、投产、运维，其中的重构可以对原有的设计和代码进行修改，运维尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性。

> 书上说开闭原则是最基础的设计原则, 但仔细严格的想想这是不太正确的.
> 
> 开闭原则应该是一种更抽象的状态, 或者是指导思想, 是精神口号, 例如`并发 vs 虚拟`, `国家发展 vs 小康社会`, 它是另外5大原则的精神领袖, 也是最终实现的状态.
> 
> **依赖倒置原则，单一职责原则，迪米特原则，接口隔离原则和里氏替换原则**都是开闭原则的具体表现形式，它指导我们建立一个稳定的、灵活的系统。但是并不代表开闭原则只包含了这5大原则, 它还有5大原则未涉及到的东西
> 实现拥抱变化的方法非常多，并不局限于这6大设计原则，但是遵循这6大设计原则基本上可以应对大多数变化。因此，我们在项目中应尽量采用这6大原则，适当时候可以进行扩充，例如通过类文件替换的方式完全可以解决系统中的一些缺陷。大家在开发中比较常用的修复缺陷的方法就是类替换，
> 
>> 文件的整理是为了更好的使用文件, 分层, 分类都是具体的方法, 但是当你真正理解文件整理的艺术, 分层和分类应该都是需要抛弃的, `更好的使用文件`应该成为文件整理唯一的实现指导.
>> 当全面理解了5大原则之后, 到了放弃5大原则的时候, 开闭原则应该是最终留下的那个

### OCP-TIP

1. OCP对测试的影响

   已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经过“千锤百炼”的测试过程，
   > 我们在程序设计阶段，一旦设计好了接口，就不应该再去修改它，因为你每次修改都会影响系统的稳定性，你修改了这个接口，就会影响其他的实现类，那么如果之前已经测试过的代码就需要重新再测试一遍，这样对整个项目周期来说，影响是非常大的。所以我们应该尽量做到只让他扩展，因为扩展你不需要对之前的代码再进行测试了，只需要测试新扩展的部分即可。

### OCP-最佳实践

1. 面向契约编程
2. 元数据(配置文件等方便修改的数据)控制模块行为
3. 制定项目章程, 约定优于配置, 做好开发规范
4. 封装变化
   - 第一，将相同的变化封装到一个接口或抽象类中；
   - 第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。
   封装变化，也就是受保护的变化（protected variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装，23个设计模式都是从各个不同的角度对变化进行封装的。

## 合成复用原则(垃圾玩意)：

尽量使用组合和聚合的方式，而不是继承的方式。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。继承的话会比较臃肿，因为继承的话就会拥有父类的所有方法，每次执行都要先去父类那边转一圈，在回到子类，能用组合的时候就用组合。

在深入理解里氏转换原则和依赖倒置原则之后, 这个原则就是个辣鸡.

里氏转换和依赖倒置原则都在道的层次, 而这个只是一个方法.

适用于那些使用别人的框架, 或者是已经搭建好的框架, 在别人已经搭建好了的框架上做开发时的情况.
