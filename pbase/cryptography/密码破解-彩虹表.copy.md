---
keys: 
type: copy,blog,trim
url: <https://zh.wikipedia.org/zh-hans/%E5%BD%A9%E8%99%B9%E8%A1%A8#>,<https://www.jianshu.com/p/732d9d960411>
---

# 密码破解的利器——彩虹表（rainbow table）

每一台需要密码认证的计算机都包含一个储存密码的数据库，密码储存方式有多种，例如摘要或纯文本。由于存储密码的表很容易被窃取，所以以纯文本形式储存密码是非常危险的。因此大多数数据库会储存用户密码的加密摘要。在这种系统内，即使是认证系统本身都无法简单地通过查表来获得用户密码。然而，当用户输入密码时，系统会生成一个加密过的消息摘要与储存的加密摘要进行比较，如果相同就允许访问请求。

黑客在盗取到散列后的密码表时，并不能仅凭借输入散列后的用户的加密摘要来获取权限（使用加密摘要作为输入密码并不可行，因为认证系统会把加密摘要再次进行散列，产生一个与储存的加密摘要不匹配的消息摘要）。为了获取用户的密码，黑客必须找到一个能产生相同加密摘要的密码。

彩虹表就是仅通过加密摘要来尝试获取用户密码的工具之一。

由于存在更为简单的逆向散列运算(hash reversal) 的方法， 彩虹表不总是会被用到。相比之下，暴力破解法和字典攻击法是更为简单的破解方法。但是这些方法在面对储存有大量密码的系统时会非常乏力（储存用于逆向查找的所有选项以及对大型数据库进行搜索是十分困难的）。

若要破解大型的密码库，则需要引入储存相对较少，但可以逆向形成长链密码的散列值的逆向查找表。虽然在破解单个的密码时会花费更多的计算时间，但这会大大降低整体的字典大小，因而可以储存更长的密码的散列值。彩虹表正是在此类链接技术的基础上改进得到的一种支持碰撞链的密码破解工具。

## 加密密码设计

方案一: 存储明文密码的Hash算码, 如`明文密码` 通过 `MD5` 算码 得到 密文
   
   构建方式: `hash(m)`
   优点: 简单
   缺点: 可以通过彩虹表破解

方案二: 存储明文密码的加盐Hash

   构建方式: `hash(m+salt)`
   salt, 可以是用户名, 手机号, 也可以是为某个用户随机生成出来的一串字符.

   优点: 当前有效防止破解

## 密码破解递进(以Hash算码为例)

> `明文密码` 通过 `MD5` 算码 得到 密文

方案一: 字典法, 事先计算好一定范围的`明文密码`和`密文`的对应关系, 之后通过密文, 反推至明文密码.

   优点: 简单, 适合很小的范围.
   缺点: 这个关系对应数量极其庞大, 需要非常多的空间.

方案二: 构建彩虹表：在字典法的基础上改进，以时间换空间。是现在破解哈希常用的办法。

### 预先计算的散列链

字典法：提前构建一个“明文->密文”对应关系的一个大型数据库，破解时通过密文直接反查明文。但存储一个这样的数据库，空间成本是惊人的。

为了减少空间成本出现了散列链

> Hash函数是将明文加密至密文的函数
> 约简函数（reduction function）R函数是构建这条链的时候定义的一个函数：它的值域和定义域与H函数相反。通过该函数可以将哈希值约简为一个与原文相同格式的值。

1. 散列链生成
   随机选择一个明文aaaaaa
   对其求哈希得到281DAF40
   R(281DAF40) 得到另外一个明文sgfnyd。
   继续重复2,3步骤
   存储的时候，不需要存储所有的节点，只需要存储每条链的头尾节点（这里是aaaaaa和kiebgt）
   以大量的随机明文作为起节点，通过上述步骤计算出哈希链并将终节点进行储存，可得到一张哈希链集。

2. 预计算的哈希链集的使用

   要破解一个hash值，

   假设其刚好是920ECF10：首先对其进行一次R运算，得到kiebgt，然后发现刚好命中了哈希链集中的（aaaaaa,kiebgt）链条。可以确定其极大概率在这个链条中。于是从aaaaaa开始重复哈希链的计算过程，发现sgfnyd的哈希结果刚好是920ECF10,于是破解成功。
   密文不是“920ECF10”而是“281DAF40”：第一次R运算后的结果并未在末节点中找到，则再重复一次H运算+R运算，这时又得到了末节点中的值“kiebgt”。于是再从头开始运算，可知aaaaaa刚好可哈希值为281DAF40。
   如是重复了k（=2）次之后，仍然没有在末节点中找到对应的值，则破解失败。

3. 预计算的哈希链集的意义

   对于一个长度为k的预计算的哈希链集，每次破解计算次数不超过k，因此比暴力破解大大节约时间。
   每条链只保存起节点和末节点，储存空间只需约1/k，因而大大节约了空间。

4. R函数的问题

   要发挥预计算的哈希链集的左右，需要一个分布均匀的R函数。当出现碰撞时，就会出现下面这种情况
   111 --H--> EDEDED --R--> 222 --H--> FEDEFE --R--> 333 --H--> FEFEDC --R--> 444
   454 --H--> FEDECE --R--> 333 --H--> FEFEDC --R--> 444 -H--> FEGEDC --R--> 555

   两条链出现了重叠。这两条哈希链能解密的明文数量就远小于理论上的明文数2×k。由于集合只保存链条的首末节点，因此这样的重复链条并不能被迅速地发现。

### 彩虹表

   彩虹表的出现，针对性的解决了R函数导致的链重叠问题：
   它在各步的运算中，并不使用统一的R函数，而是分别使用R1…Rk共k个不同的R函数（下划线表示下标）。

   这样一来，及时发生碰撞，通常会是下面的情况：
   111 --H--> EDEDED --R1--> 222 --H--> FEDEFE --R2--> 333 --H--> FEFEDC --R3--> 444
   454 --H--> FEDECE --R1--> 333 --H--> FEFEDC --R2--> 474 -H--> FERFDC --R3--> 909

   即使在极端情况下，两个链条同一序列位置上发生碰撞，导致后续链条完全一致，这样的链条也会因为末节点相同而检测出来，可以丢弃其中一条而不浪费存储空间。


彩虹表的使用

   彩虹表的使用比哈希链集稍微麻烦一些。

   首先，假设要破解的密文位于某一链条的k-1位置处，对其进行Rk运算，看是否能够在末节点中找到对应的值。如果找到，则可以如前所述，使用起节点验证其正确性。
   否则，继续假设密文位于k-2位置处，这时就需要进行Rk-1、H、Rk两步运算，然后在末节点中查找结果。
   如是反复，最不利条件下需要将密文进行完整的R1、H、…Rk运算后，才能得知密文是否存在于彩虹表之中。
   彩虹表中时间、空间的平衡
   对于哈希链集，最大计算次数为k，平均计算次数为k/2
   彩虹表的最大计算次数为1+2+3+……k = k(k-1)/2，平均计算次数为[(k+2) * (k +1)]/6。
   可见，要解相同个数的明文，彩虹表的代价会高于哈希链集。

   无论哈希链集还是彩虹表：
   当k越大时，破解时间就越长，但彩虹表所占用的空间就越小；
   相反，k越小时，彩虹表本身就越大，相应的破解时间就越短。

常见的彩虹表和R函数举例
1）常见的彩虹表：http://project-rainbowcrack.com/table.htm
2）R函数举例：假设明文为5位数字，则R函数是取哈希值中前5个数字。参见https://crypto.stackexchange.com/questions/5900/example-rainbow-table-generation


## 为什么加盐哈希可以抵御彩虹表

彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。
如果每个用户都用一个不同的盐值，那么每个用户的H函数都不同，则必须要为每个用户都生成一个不同的彩虹表。大大提高了破解难度。
