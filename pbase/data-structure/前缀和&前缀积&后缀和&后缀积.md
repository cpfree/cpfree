

树状数组：O(n log n)（做n次加法，每次加法为log n）

树状数组适合在：多次求和，多次修改，数据量大的场景下使用。

如果无需支持修改，建议使用前缀和，构造O(n)，求和O(1)



## 前缀和、前缀积？

> 参考网址: <https://www.cnblogs.com/AndyJee/p/4474073.html>

前缀和、前缀积也称前缀和数组，前缀积数组。

给一数组A，

前缀和：新建一数组B，数组中每一项B[i]保存A中[0…i]的和；

后缀和：新建一数组B，数组中每一项B[i]保存A中[i…n-1]的和；

前缀积：新建一数组B，数组中每一项B[i]保存A中[0…i]的积；

后缀积：新建一数组B，数组中每一项B[i]保存A中[i…n-1]的积；

## 题目示例

1. 给定浮点数组a，求一数组b，b[i]=a[0]*a[1]*…*a[i-1]*a[i+1]*…*a[n-1]，不能使用除法，不允许新开数组。

   思路：

   先求“后缀积”：

   for(int i=n-1;i>=0;i—) b[i]=a[i]*((i==n-1)?1:b[i+1]);

   顺带求“前缀积”：

   for(int i=0,j=1;i<n;j*=a[i++]) b[i]=j*((i==n-1)?1:b[i+1]);

2. 求数组中连续一段和，绝对值最小？

   前缀和的性质：a[i]+a[i+1]+…+a[j]=sum[j]-sum[i-1]

   前缀和排序，取最小

3. 把一个数组从中间p位置分开，使得a[0]+…+a[p-1]与a[p]+a[p+1]+…+a[n-1]差值最小？

   方案一: 建立前缀和数组, 最后一个数是数组总和sum, 再从前缀和数组中找到离 sum/2 最近的数
   方案二: 如果都是非负数，可以采取“两头扫”的方法，设置两个和 s1, s2, 分别从左从右对数组中的数进行累加, 加完之后进行比较, 和较小的那边再次进行累加操作, 直到整个数组累加完成.
 
