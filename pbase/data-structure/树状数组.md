# 树状数组

> 参考链接：https://blog.csdn.net/bjweimengshu/article/details/116617098の

树状数组，Binary Indexed Tree（简称BIT），是由Peter M. Fenwick在1994年发明的

对于一些集合的重复运算, 树状数组可以提前计算好一些区域, 反复使用. 

树状数组适合在：多次求和，多次修改，数据量大的场景下使用。

例题: 
   
   现在有一个数组a，我们需要求很多次数组中不同区间的和，而且多次对a中随意一项进行更改。
   比如说a = {0, 1, 5, 3, 2, 4}

   第一次求[1, 3]，得到1 + 5 + 3 = 9
   第二次求[2, 4]，得到5 + 3 + 2 = 10
   第三次，这时候我把a[2] += 2
   第四次求[1, 5]，得到1 + 7 + 3 + 2 + 4 = 17

   > [l, r]表示从下标l开始，到r结束的区间，包含l和r。

   如果计算量过多, 每一次计算将数组中的数挨个加起来太慢, 做了很多重复的工作？
   能不能提前加好一些区域，反复使用呢？

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/v2-31056dc2143b4614ac0ed4bfd3f4e4bd_r.jpg)

## lowbit 函数

lowbit这个函数的功能就是求某一个数的二进制表示中最低的一位1，

   > 举个例子，x = 6，它的二进制为110，那么lowbit(x)就返回2。

   > lowbit(i) 可以还解释为：i中最低位的1以及后面的0；或者你可以把它理解成i能被n整除，n还可以写成2k
   >
   > 例如 6 的二进制是`110`, 那么`lowbit(6)` 就是 `10`, 也就是2

那么怎么求lowbit呢？

1. 方案一: 先消掉最后一位1，然后再用原数减去消掉最后一位1后的数，答案就是lowbit(x)的结果；

   ```js
   int lowbit(x) {   
      return x - (x & (x - 1));
   }
   ```

2. 方案二: 第二种方法就是计算机组成原理课上老师教过我们求负数的补码的简便方法：把这个数的二进制写出来，然后从右向左找到第一个1(这个1就是我们要求的结果，但是现在表示不出来，后来的操作就是让这个1能表示出来)，这个1不要动和这个1右边的二进制不变，左边的二进制依次取反，这样就求出的一个数的补码，说这个方法主要是让我们理解一个负数的补码在二进制上的特征，然后我们把这个负数对应的正数与该负数与运算一下，由于这个1的左边的二进制与正数的原码对应的部分是相反的，所以相与一定都为0,；由于这个1和这个1右边的二进制都是不变的，因此，相与后还是原来的样子，故，这样搞出来的结果就是lowbit(x)的结果。

   ```js
   int lowbit(x) {
      return x & -x;
   }
   ```

## 树状数组

树状数组是个数组，可外表下藏着二叉树的结构。

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/v2-31056dc2143b4614ac0ed4bfd3f4e4bd_r.jpg)

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/20210901233321.png)

## 建立树状数组(以加法为例)

假如原始数组是 raw 数组, 树状数组名为 bit

那么对于每个树状数组中的值来说, bit[i] = 在数组a中从 `i - lowbit(i) + 1` 到 i 求和

   ```code
   bit[i] = raw[i - lowbit(i) + 1] + .... + raw[i] 的和
   ```

   > bit[3] 对应 raw的[3, 3] 的和
   > bit[4] 对应 raw的[1, 4] 的和
   > bit[8] 对应 raw的[1, 8] 的和
   > bit[16] 对应 raw的[1, 16] 的和

综合考虑可以这样

   1. 把数组bit全初始化为0
   2. 遍历整个数组raw
   3. 对于每一个数组a[i]，都对bit进行add(i, a[i])
   4. 直到循环完成整个raw, 建立好对应的bit数组

## 树状数组更改

假如说, raw 数组更改一个数值(第三个数), 导致bit数组也需要更改数值

对于raw来说, 只需要更改数组中的一个子就好了raw[3], 但是对于树状数组bit来说, 树状数组中好几个值都可能会用到这个raw[3], 那么就需要同步更改好几个数值.

在图中，我们可以看出，4在3头上，8在4头上，16在8头上。我们只需要找到一种方式，得到一个块 头上的块，然后使用循环能推出整串。

如何找到自己头上的数呢？

我们发现，在当前块的位置加上当前块的长度之后能跳到头上。

> bit[i] 的长度刚好是 lowbit(i)

> 例如: bit[3] 的长度是1, 3 + 1 = 4, 刚好是自己头上的数.
> 
> bit[6] 的长度是2, 6 + 2, 也刚好是自己头上的数8

```c
void add(int index, long long value) {
    while (index <= n) { // 更新直到最大的块
        node[index] += value; // 更新当前的块
        index += lowbit(index); // 加上一个自己的长度，补上空缺，得到下一个块
    }
}
```

### 区间求和

例如[1, r]的求和
   
   从右往左取块，将块代表的数值加起来即可

   第一次取到13，长度为lowbit(13) = 1
   第二次13取完了从12开始取，长度为4，一次性将[9, 12]取完
   第三次[9, 13]取完了从8开始，长度为8，取走[1, 8]，到此[1, 13]全部取走

   ```c
   long long sum(int index) {
      long long sum = 0;
      while (index > 0) {
         sum += node[index];
         index -= lowbit(index);
      }
      return sum;
   }
   ```

那如果求和左端点不在1处呢？

   对[l, r]求和，可以写成sum(r) - sum(l - 1)
   先把大区域[1, r]求出来，然后扣掉[1, l - 1]的部分，不就是[l, r]吗？

### 时间复杂度对比

下面的暴力指的是开头提到的挨个相加。

操作类型 | 时间复杂度
-|-
构造 | O(n)（当做是读入的复杂度）
求和 | O(log n)（结构与二叉树相仿）
更改 | O(log n)（需要改一串，但结构与二叉树相仿）
