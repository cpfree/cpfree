---
keys: 并发,原子性,可见性,有序性
type: copy,blog,trim
url: <>
id: 211125-210659
---

并发的三个基本特性是指 `原子性`,`可见性`,`有序性`.

## 并发编程的三个基本特性

- **原子性**: 一个操作(程序片段)是不可中断的，要么全部执行成功要么全部执行失败.
- **可见性**: 当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。
- **有序性**: 在本线程内观察，所有的操作都是有序的；在一个线程中观察另一个线程，所有的操作都是无序的。后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象

CPU 的乱序执行会导致有序性问题, 有序性会导致可见性问题, 我们关心的并不是**有序性**, 我们关心的实际上是**可见性问题**.

导致可见性问题的原因有两个, 一个是 CPU 的高速缓存带来的缓存一致性问题, 另一个就是指令重排序.

|            | **解决方案**                      |
| ---------- | --------------------------------- |
| **原子性** | **synchronized,Automic,lock,CAS** |
| **可见性** | **synchronized,volatile,final**   |
| **有序性** | **synchronized,volatile,final**   |

### 原子性:

JMM 内存模型中直接保证的原子性操作: read、load、assign、use、store 和 write 这六个.

原子性的语句:

1. 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（_例外就是 long 和 double 的非原子性协定_）。
2. 单纯的赋值操作是原子性的
3. synchronized 块具有原子性：Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。这两个字节码指令反映到 Java 代码中就是同步块——**synchronized**关键字，因此在 synchronized 块之间的操作也具备原子性。

Q: 测试, 下面的四条语句哪些是原子性的.

```java
int a = 5;
a ++;
int b = a;
a = a + 1;
```

A: 只有第一条 `int a = 5` 是原子性的操作.
`a ++`, 和 `a = a + 1` 均包含了三个操作, ① 读取变量 a 的值,② 对 a 加一,③ 将计算的值赋给 a.
`int b = a` 有两个操作, 一个是读取 a 的值, 另一个之将 a 的值赋给 b.

---

#### java 中 long 和 double 的非原子性协定

Java 内存模型对于 64 位的数据类型(long 和 double)，特别定义了一条规定:
允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行。即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。不过目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此编码时，一般不需要把用到的 long 和 double 变量专门声明为 volatile。

### 可见性

可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。

java 中有 3 种方式能够实现可见性

1. volatile: Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。普通变量与 volatile 变量的区别是，**volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。**
2. synchronized：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作），而 synchronized 块前后是 lock 和 unlock 操作。
3. final：被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值。

### 有序性（Ordering）

**如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。**前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java 语言提供了 volatile 和 synchronized 和 final 关键字来保证线程之间操作的有序性。

1. volatile：volatile 本身就包含了禁止指令重排序的语义。
2. synchronized：一个变量在同一个时刻只允许一条线程对其进行 lock 操作，这个规则决定了持有同一个锁的两个同步块只能串行地进入。
3. final 也可以禁止指令重排序, 它主要通过禁止指令重排序来保证 final 变量在使用之前确实被初始化完成.

> synchronized 关键字在需要这三种特性的时候都可以作为其中一种的解决方案？synchronized 的“万能”也间接造就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响。
