# 分布式漫谈

[TOC]

## 分布式架构

### 分布式架构的意义

1. 单机处理能力存在瓶颈
2. 升级单机处理能力的性价比越来越低
3. 稳定性和可用性这两个指标很难达到

## 分布式架构的基本理论

### CAP

概念
   一致性（C：Consistency）：所有节点上的数据时刻保持同步
   可用性（A：Availability）：每个请求都能接收一个响应，无论响应成功或失败
   分区容错（P：Partition tolerance）：系统应该持续提供服务，即时系统内部（某个节点分区）有消息丢失。比如交换机失败、网址网络被分成几个子网，形成脑裂；服务器发生网络延迟或死机，导致某些 server 与集群中的其他机器失去联系

CAP 理论 : 一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中两项。

我们没有办法找到一种能够满足数据一致性、又不影响系统运行的性能的方案，所以这个地方就诞生了一个一致性的级别：

1. 强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
2. 弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
3. 最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较用的多的模型

### BASE

BASE 全称是 Basically available, soft-state, Eventually Consistent.系统基本可用、软状态、数据最终一致性。相对于 CAP 来说，它大大降低了我们对系统的要求。

Basically available（基本可用），在分布式系统出现不可预知的故障时，允许瞬时部分可用性

   1. 比如我们在淘宝上搜索商品，正常情况下是在 0.5s 内返回查询结果，但是由于后端的系统故障导致查询响应时间变成了 2s
   2. 再比如数据库采用分片模式，100W 个用户数据分在 5个数据库实例上，如果破坏了一个实例，那么可用性还有 80%，也就是 80%的用户都可以登录，系统仍然可用做技术人的指路明灯，做职场生涯的精神导师
   3. 电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现

soft-state（软状态）. 表示系统中的数据存在中间状态，并且这个中间状态的存在不会影响系统的整体可用性，也就是表示系统允许在不同节点的数据副本之间进行数据同步过程中存在延时；比如订单状态，有一个待支付、支付中、支付成功、支付失败， 那么支付中就是一个中间状态，这个中间状态在支付成功以后，在支付表中的状态同步给订单状态之前，中间会存在一个时间内的不一致。

Eventually consistent（数据的最终一致性），表示的是所有数据副本在一段时间的同步后最终都能达到一个一直的状态，因此最终一致性的本质是要保证数据最终达到一直，而不需要实时保证系统数据的强一致

BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性

## 主流架构模型

### SOA(Service Oriented Architecture)

SOA 全称（Service Oriented Architecture），中文意思为"面向服务的架构"，他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的

SOA 所解决的核心问题

   1. 系统集成：站在系统的角度，解决企业系统间的通信问题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构，这一步往往需要引入一些产品，比如 ESB、以及技术规范、服务管理规范；这一步解决的核心问题是【有序】
   2. 系统的服务化：站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用；这一步解决的核心问题是【复用】
   3. 业务的服务化：站在企业的角度，把企业职能抽象成可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；"前面两步都是从技术层面来解决系统调用、系统功能复用的问题"。第三步，则是以业务驱动把一个业务单元封装成一项服务。这一步解决的核心问题是【高效】

> ESB全称为Enterprise Service Bus，即企业服务总线。ESB是将所有的系统的交互都放在SOA统一服务总线上面来控制处理, 它是传统中间件技术与XML、Web服务等技术结合的产物。ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。

### 微服务架构

微服务架构其实和 SOA 架构类似,微服务是在 SOA 上做的升华，微服务架构强调的一个重点是"业务需要彻底的组件化和服务化"，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。
微服务的特征

   1. 通过服务实现组件化
   2. 按业务能力来划分服务和开发团队
   3. 去中心化
   4. 基础设施自动化（devops、自动化部署）

### SOA 和微服务架构的差别

1. 微服务不再强调传统 SOA 架构里面比较重的 ESB 企业服务总线，同时 SOA 的思想进入到单个业务系统内部实现真正的组件化
2. Docker 容器技术的出现，为微服务提供了更便利的条件，比如更小的部署单元，每个服务可以通过类似 Node或者 Spring Boot 等技术跑在自己的进程中。
3. 还有一个点大家应该可以分析出来，SOA 注重的是**系统集成方面**，而微服务关注的是**完全分离**

## 领域驱动设计及业务驱动划分

### 领域驱动设计的概念

   领域驱动设计（DDD,Domain-Driven Design），软件开发不是一蹴而就的事情，我们不可能在不了解产品（或行业领域）的前提下进行软件开发，在开发前，通常需要进行大量的业务知识梳理，然后才到软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念, DDD 理解起来有点抽象, 这个有点像设计模式，

### 业务驱动划分 步骤

   1. 针对功能层面划分边界
   2. 确认基本需求
   3. 针对产品功能划分边界
   4. 细化上下文
      1.任务更好拆分（一个开发人员可以全身心投入到相关子域的上下文中），
      2.方便沟通，明确自身上下文和其他上下文之间的依赖关系，可以实现更好的对接
   5. 然后是基于上下文的更进一步细化建模，

### DDD相关概念

   1. 实体 : 当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。
   2. 值对象 : 当一个对象用于对事物进行描述而没有唯一标识时，它被称作值对象
   3. 聚合根 : 聚合根属于实体对象，它是领域对象中一个高度内聚的核心对象。（聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法）
   4. 领域服务 : 一些重要的领域行为或操作，可以归类为领域服务。它实现了全部业务逻辑并且通过各种校验手段保证业务的正确性。
   5. 资源库 : 资源封装了基础设施来提供查询和持久化聚合操作。这样能够让我们始终关注在模型层面，把对象的存储和访问都委托给资源库来完成。他不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD 关心的是领域内的模型，而不是数据库的操作。

### DDD的好处

1. 可以很好的解决领域模型到设计模型的同步、演进最后映射到实际的代码逻辑。
2. DDD 能够让我们知道如何抽象出限界上下文上下文以及如何去分而治之
3. DDD 的限界上下文可以完美匹配微服务的要求
