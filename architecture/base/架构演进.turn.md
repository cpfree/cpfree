---
keys: 
type: trim
url: <>
id: 220124-124228
---

# 架构漫谈

> 参考书籍: Spring Cloud Alibaba
> 参考url: https://zhuanlan.zhihu.com/p/61901608

## 架构演进

![架构演进](https://gitee.com/cpfree/picture-warehouse/raw/master/pic/20210616151106.png)

### 一. 单体架构

单体架构设计内容主要包含 Spring、Struts、Hibernate、MySQL等技术。

架构非常简单: 通常来说，如果一个war包或者jar包里面包含一个应用的所有功能. 
效率高: 能够快速开发和上线。而且对于项目初期用户量不大的情况，这样的架构足以支撑业务的正常运行。
适用于小型项目

单体架构面临挑战:

   1. 用户量和网站的访问量不断增大，导致后端服务器的负载越来越高, 响应会越来越慢。
   2. 业务场景越来越多并且越来越复杂, war包中的代码量会持续上升, 业务代码之间的耦合度也会越来越高, 维护越来越困难.

### 二. 集群及垂直化

集群及垂直化从两个方面解决单体架构的问题：

   1. 通过横向增加服务器，把单台机器变成多台机器的集群。
   2. 按照业务的垂直领域进行拆分，减少业务的耦合度，以及降低单个war包带来的伸缩性困难问题。

集群及垂直化方式:

   1. 应用服务器和数据库服务器分离: 提升负载能力，容灾能力.
   2. 服务器集群: 添加多个服务器, 并配置负载均衡器.
      优点 : 提升了负载能力
      问题 :
      - 用户请求由谁来转发到具体的应用服务器
      - 用户如果每次访问到的服务器不一样，那么如何维护session
   3. 数据库读写分离
      - 数据库不统一, 主从数据库之间的数据同步 : 可以使用 mysql 自带的 **master-slave** 方式实现主从复制
      - 对应数据源的选择 : 采用第三方数据库中间件，例如 **mycat**
   4. 使用搜索引擎缓解读库的压力
      解决了模糊查找效率不是特别好的问题, 大大提高我们的查询速度，但是同时也会带来一些附加的问题，比如维护索引的构建
   5. 引入缓存机制缓解数据库的压力
      热点数据，没必要每次都从数据库去读取，我们可以使用缓存技术，比如 memcache、redis 来作为我们应用层的缓存；
      某些场景下，比如我们对用户的某些IP的访问频率做限制，那这个放内存中又不合适，放数据库又太麻烦，这个时候可以使用Nosql 的方式比如 mongDB
   6. 数据库的水平/垂直拆分
      数据库的瓶颈仍然是个最大的问题。因此我们可以考虑对数据的垂直拆分和水平拆分
      垂直拆分：把数据库中不同业务数据拆分到不同的数据库
      水平拆分：把同一个表中的数据拆分到两个甚至跟多的数据库中

集群及垂直化面临问题

   1. 业务重用问题: 整个系统中，一定会存在非常多共享业务的场景，这些业务场景的逻辑会被重复创建，从而产生非常多冗余的业务代码，这些冗余代码的维护成本会随着时间的推移越来越高.
      
      > 如一个用户执行下单操作，系统的处理逻辑是先去库存子系统检查商品的库存，只有在库存足够的情况下才会提交订单，那么这个检查库存的逻辑是放在订单子系统中还是库存子系统中呢
   2. 信息孤岛问题: 一个集团公司下有很多子公司，每个子公司都有自己的业务模式和信息沉淀，各个子公司之间不进行交互和共享。这个时候每个子公司虽然能够创造一定的价值，但是由于各个子公司之间信息不是互联互通的，彼此之间形成了信息孤岛，使得价值无法最大化。

### 三. SOA

SOA(Service-Oriented Architecture), 语义是面向服务的架构, 和面向过程、面向对象、面向组件的思想是一样的，都是一种软件组建及开发的方式。

核心目标是把一些通用的、会被多个上层服务调用的共享业务提取成独立的基础服务，这些被提取出来的共享服务相对来说比较独立，并且可以重用。所以在SOA中，服务是最核心的抽象手段，业务被划分为一些粗粒度的业务服务和业务流程。

SOA 遇到的问题

   1. 服务拆分以后，各个服务之间如何进行远程通信
      
      >  RPC 技术，比较典型的有：webService、hessian、http、RMI等等

SOA 缺陷

   1. 过分使用ESB：使得系统集成过于复杂使用基于SOAP协议的WS：使得通信的额外开销很大使用形式化的方式管理：增加了服务管理的复杂度需要使用可靠的ESB：初始投资比较高

### 四. 微服务(Microservices)

业务系统实施服务化改造之后，原本共享的业务被拆分形成可复用的服务，可以在最大程度上避免共享业务的重复建设、资源连接瓶颈等问题。那么被拆分出来的服务是否也需要以业务功能为维度来进行拆分和独立部署，以降低业务的耦合及提升容错性呢？

微服务架构将每个具体的业务服务构成可独立运行的微服务，每个微服务只关注某个特定的功能，服务之间采用轻量级通信机制REST API进行通信。微服务的粒度越小，服务独立性带来的好处就越多，但是管理大量的微服务也会越复杂。

服务粒度细化之后, 服务较多, 开发难度降低, 迭代较快, 运维成本变高, 等等原因使微服务会更多地关注在DevOps的持续交付上，同时微服务与容器化技术的结合更加紧密。

![img](https://gitee.com/cpfree/picture-warehouse/raw/master/pic/20210616151117.png)

微服务架构主要的目的是实现业务服务的解耦。随着公司业务的高速发展，微服务组件会越来越多，导致服务与服务之间的调用关系越来越复杂。同时，服务与服务之间的远程通信也会因为网络通信问题的存在变得更加复杂，比如需要考虑重试、容错、降级等情况。那么这个时候就需要进行服务治理，将服务之间的依赖转化为服务对服务中心的依赖。除此之外，还需要考虑：

1. 分布式配置中心。
2. 服务路由。
3. 负载均衡。
4. 熔断限流。
5. 链路监控。

微服务不仅仅是带来服务拆分、编排管理、持续集成、部署等一系列问题，微服务内部也会有很多问题，诸如：

![img](https://gitee.com/cpfree/picture-warehouse/raw/master/pic/20210616151122.png)

针对企业使用微服务架构后带来的一系列，也就有了服务治理平台。

![img](https://gitee.com/cpfree/picture-warehouse/raw/master/pic/20210616151127.png)

#### 微服务和SOA的区别和联系

面向服务（SOA）和微服务本质上都是服务化思想的一种体现。如果SOA是面向服务开发思想的雏形，那么微服务就是针对可重用业务服务的更进一步优化，我们可以把SOA看成微服务的超集，也就是多个微服务可以组成一个SOA服务。伴随着服务粒度的细化，会导致原本10个服务可能拆分成了100个微服务，一旦服务规模扩大就意味着服务的构建、发布、运维的复杂度也会成倍增加，所以实施微服务的前提是软件交付链路及基础设施的成熟化。因此微服务在我看来并不是一个新的概念，它本质上是服务化思想的最佳实践方向。

由于SOA和微服务两者的关注点不一样，造成了这两者有非常大的区别：

1. SOA关注的是**服务的重用性**及解决信息孤岛问题。微服务关注的**降低业务之间的耦合度**。
2. SOA尝试将应用集成，一般采用中央管理模式来确保各应用能够交互运作。微服务更倾向于**分布式去中心化**的部署方式，着重于**分散管理**、代码再利用与自动化执行, 快速部署新功能，快速有效地扩展开发团队。原则**与敏捷软件开发思想是高度一致**的, 在互联网业务场景下更适合；

#### 微服务架构的优点

微服务架构有很多好处，下面简单罗列了几个比较突出的点。

1. 复杂度可控：通过对共享业务服务更细粒度的拆分，一个服务只需要关注一个特定的业务领域，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，开发、维护会更加简单。
2. 技术选型更灵活：每个微服务都由不同的团队来维护，所以可以结合业务特性自由选择技术栈。例如HTTP RESTful方式，各种终端都可以调用，无关语言、平台限制；
3. 可扩展性更强：可以根据每个微服务的性能要求和业务特点来对服务进行灵活扩展，比如通过增加单个服务的集群规模，提升部署了该服务的节点的硬件配置。
4. 独立部署：由于每个微服务都是一个独立运行的进程，所以可以实现独立部署。当某个微服务发生变更时不需要重新编译部署整个应用，并且单个微服务的代码量比较小，使得发布更加高效。
5. 容错性：在微服务架构中，如果某一个服务发生故障，我们可以使故障隔离在单个服务中。其他服务可以通过重试、降级等机制来实现应用层面的容错。

#### 微服务架构面临的挑战

在微服务架构的过程中，我们经常会遇到数据库的拆分、API交互、大量的微服务开发和维护、运维等问题。即便成功实现了微服务的主体，也还是会面临下面这样一些挑战。

1. 消息与并行方式使得系统的开发门槛增加分布式系统的复杂性也会让系统的测试变得复杂
2. 服务监控：在一个单体架构中很容易实现服务的监控，因为所有的功能都在一个服务中。在微服务架构中，服务监控开销会非常大，可以想象一下，在几百个微服务组成的架构中，我们不仅要对整个链路进行监控，还需要对每一个微服务都实现一套类似单体架构的监控。
3. 分布式架构的复杂性：微服务本身构建的是一个分布式系统，分布式系统涉及服务之间的远程通信，而网络通信中网络的延迟和网络故障是无法避免的，从而增加了应用程序的复杂度。
4. 服务依赖：微服务数量增加之后，各个服务之间会存在更多的依赖关系，使得系统整体更为复杂。假设你在完成一个案例，需要修改服务A、B、C，而A依赖B，B依赖C。在单体式应用中，你只需要改变相关模块，整合变化，再部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务C，然后是B，最后才是A，幸运的是，许多改变一般只影响一个服务，需要协调多服务的改变很少。
5. 运维成本：在微服务中，需要保证几百个微服务的正常运行，对于运维的挑战是巨大的。比如单个服务流量激增时如何快速扩容、服务拆分之后导致故障点增多如何处理、如何快速部署和统一管理众多的服务等。

### 五. Service Mesh

Service Mesh是微服务时代的TCP协议。



### serverless

