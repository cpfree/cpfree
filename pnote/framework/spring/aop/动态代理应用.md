# 动态代理应用

1. java

   动态代理

## 植入

1. 静态织入

   aspectJ 拥有强大的静态植入能力

2. asm 动态植入，以及java中的动态代理

## AOP 和 aspectJ

Spring中使用了AspectJ，AspectJ能提供了强大的静态织入能力，很多人也想当然的认为AspectJ是Aop的一种织入方式，事实上Spring做了取舍，只集成了后者的语法，保留了自身的动态织入，利用后者解析AspectJ风格的表达式并生成Advisor，最终对target的织入只有JDK dynamic和Cglib两种方式。

Spring的AOP框架的基于代理的性质，`保护的方法是通过定义不拦截`，既不是JDK代理（其中，这是不适用），也不是CGLIB代理（其中这在技术上是可行的，但不建议用于AOP目的）。

Spring的AOP框架 对于 任何给定的切入点将仅与公共方法匹配！

如果您的拦截需求包括`protected/private`方法或`构造函数`，请考虑使用`Spring`驱动的本机`AspectJ`编织，而不是`Spring`的基于代理的AOP框架。

### 案例场景

假如有个类 `cn.a.Test`, 其中有一个方法 `protect void fun()`.

1. 使用AOP直接拦截保护方法

   ```java
   @Pointcut("execution(protected cn.a.Test.fun(..))") 
   ```

   > 如果写了protected，他就什么事情都不做，连protected的方法也不拦截。

2. 如果改为如下切入表达式

   ```java
   @Pointcut("execution(* cn.a.Test.fun(..))") 
   ```

   > 把 protected 换成 *, 则什么都匹配不到, 但是也不报错.

