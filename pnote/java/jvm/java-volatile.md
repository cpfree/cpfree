# volatile

## volatile用两个作用

当一个变量被定义成volatile之后，它将具备两项特性

- 可见性: 保证此变量对所有线程可见, 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。
- 禁止指令重排序：volatile通过生成内存屏障来禁止指令重排序，从而保证有序性.

#### volatile如何保证可见性的

可见性是并发编程中需要解决的几个问题之一，CPU保证可见性的解决方法是[缓存一致性协议](/pbase/protocol/缓存一致性协议MESI.md)，例如比较有名的MESI协议。

JVM是一个虚拟机，因此在真正运行的时候是没有办法和CPU硬件进行一一匹配的，因此JVM设计了一套JMM模型来处理线程之间的并发问题，虽然其底层用的依然是CPU中的 `缓存一致性协议`。

JMM是一个抽象的概念。JMM通过6个原子操作来借助MESI缓存一致性协议和总线嗅探机制才得以完成。

此外，当CPU不支持缓存一致性协议时，还是需要依靠总线加锁的形式来保证线程安全。

**既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile保证可见性呢？**

1. JMM是虚拟机在CPU硬件之上做的一层抽象模型，简单来说MESI对应的是CPU硬件模型，volatile对应的是JMM，而CPU硬件模型和JMM之间并不是一一匹配的。例如JMM中的线程内存并不一定在缓存上面，也可能JVM某个时间为了节省资源将其移到了内存里面。
2. 并不是所有CPU都支持MESI，也有的CPU不支持MESI，但是JVM依然能够通过JMM的抽象使得java语言在不同硬件之间达成一致。
3. MESI协议最多只是保证了对于一个变量，在多个核上的读写顺序，对于多个变量而言是没有任何保证的。volatile可以保证多个变量之间的读写顺序，哪怕多个变量之间没有指令之间的控制依赖，数据依赖，地址依赖等等。

### volatile通过生成内存屏障来禁止指令重排序，从而保证有序性

#### CPU中的内存屏障

内存屏障是一种底层原语。它使得 CPU 或编译器在对内存进行操作的时候, 要严格按照一定的顺序来执行, 也就是说在 memory barrier 之前的指令和 memory barrier 之后的指令不会由于系统优化等原因而导致乱序。

内存屏障提供了两个功能。

1. 在 memory barrier 之前的指令和 之后的指令不会由于系统优化等原因而导致乱序。
2. 实现内存数据可见性，确保内存数据会同步到 CPU 缓存子系统。

通常情况下，硬件为我们提供了四种类型的内存屏障。

| CPU内存屏障类型 | 前置操作 | 后续操作 | 描述                                    |
| --------------- | -------- | -------- | --------------------------------------- |
| LoadLoad        | Load     | Load     | 保证屏障前面的Load在后面的load之前执行  |
| LoadStore       | Load     | Store    | 保证屏障前面的Load在后面的Store之前执行 |
| StoreLoad       | Store    | Load     | 保证屏障前面的Store在后面的load之前执行  |
| StoreStore      | Store    | Store    | 保证屏障前面的Store在后面的Store之前执行  |

#### JVM对内存屏障的使用

JVM使用volatile保守的使用这些屏障。如下图所示，jvm在生成内存屏障的时候，若是前面是volatile读，后面有volatile读，则会在其中间生成一个LoadLoad屏障。

| 前置操作\后续操作 | 普通读   | 普通写    | volatile读 | volatile写 |
| ----------------- | -------- | --------- | ---------- | ---------- |
| 普通读            |          |           |            | LoadStore  |
| 普通写            |          |           |            | StoreStore |
| volatile读        | LoadLoad | LoadStore | LoadLoad   | LoadStore  |
| volatile写        |          |           | StoreLoad  | StoreStore |

### 禁止指令重排保证执行顺序。

重排序分为编译器重排序、处理器重排序和内存重排序。我们说的 volatile 会禁用指令重排序，实际上 volatile 禁用的是**编译器重排序**和**处理器重排序**。

volatile在指令重排序时，第一步操作是否能够移动到第二步操作后面

| 第一操作\第二步操作 | 普通读写 | volatile读 | volatile写 |
| ------------------- | -------- | ---------- | ---------- |
| 普通读写            | ✔       | ✔         | ✘         |
| volatile读          | ✘       | ✘         | ✘         |
| volatile写          | ✔       | ✘         | ✘         |

1. volatile读屏障之后的操作不能移到读屏障之前
2. volatile写屏障之前的操作不能移到写屏障之后。
3. volatile语句之间的操作不能重排序。

### JVM 在底层对volatile的处理

JVM层面如果是储存结果的语句中, 变量被 volatile修饰, 那么会加一个 storeload()指令, 加一个storeload屏障.

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1638272057057-8cbcb097-3e36-49e3-89da-f23bceca72d1.png)



