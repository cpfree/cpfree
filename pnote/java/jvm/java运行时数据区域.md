---
keys: 运行时数据区域,常量池
type: copy,blog,trim
url: <>
id: 211128-180014
---

# note

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

## Java运行时数据区域

![Java运行时数据区域](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1638091463826.png)

1. 程序计数器(Program Counter Register)
   **每条线程都需要有一个独立的程序计数器**, 属于**线程私有**的数据区域, 是一小块内存空间, 容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值, 主要代表**当前线程所执行的字节码行号指示器**。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
  
2. 虚拟机栈(Java Virtual Machine Stacks)
   **每个线程都有一个专用的 Java 虚拟机堆栈**，与线程同时创建。Java 虚拟机堆栈存储帧。代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程.

   下列异常情况与 Java 虚拟机堆栈相关
      - StackOverflowError 线程请求分配的栈容量超过 JVM 栈允许的最大容量
      - OutOfMemoryError 栈可以动态扩展，在尝试扩展时无法申请到足够的内存

3. JVM堆（Java Heap）
   堆是 **虚拟机启动时创建的** **供各个线程共享的** **运行时数据区域**. 主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆
   从中分配所有类实例和数组的内存。对象的堆存储由自动存储管理系统(垃圾收集器)回收;
   堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，还可以进行收缩。堆的内存不需要是连续的。
   
4. 本地方法栈(Native Method Stacks)
   本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。
   - StackOverflowError: 如果线程中的计算需要比允许的更大的本机方法堆栈，那么 Java 虚拟机抛出一个 StackOverflowError。
   - OutOfMemoreyError: 如果本机方法堆栈可以动态扩展，本机方法堆栈扩展可以尝试，但是没有足够的内存可用，或者如果没有足够的内存可用来为新线程创建初始的本机方法堆栈，Java 虚拟机将抛出 OutOfMemoryError。

5. 方法区（Method Area）
   方法区属于线程共享的内存区域，主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。
   - OutOfMemoryError: 如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 OutOfMemoryError。

6. 运行时常量池
   运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
   运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。
   既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
   
7. 直接内存
   直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。
   在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
   显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

| 运行时数据区域 |                                                                            | 生命周期       | 异常                                                                                                                                                                         |
| -------------- | -------------------------------------------------------------------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 方法区         |                                                                            |                | 方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。                                                                                                               |
| 堆             | 被所有线程共享的一块内存区域，<br />此内存区域的唯一目的就是存放对象实例， | 虚拟机启动创建 | 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。                                                                                     |
| 程序计数器     | 当前线程所执行的字节码的行号指示器                                         | 线程独有       |                                                                                                                                                                              |
| 虚拟机栈       | 为虚拟机执行Java方法（也就是字节码）服务                                   | 线程独有       | 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；<br />如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 |
| 本地方法栈     | 为虚拟机使用到的本地（Native）方法服务。                                   |                | 与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。                                                                 |

## 常量池

《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

#### 字符串常量池

string pool在每个HotSpot VM的实例只有一份，被所有的类共享。
string pool中存的是引用值而不是具体的实例对象，字符串常量池是在本地内存当中，具体的实例对象是在堆中开辟的一块空间存放的, 在jdk1.8后，将String常量池放到了堆中。

#### class常量池

当java文件被编译成class文件之后，会在class文件中生成我们所说的class常量池，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(文本字符串、被声明为final的常量、基本数据类型的值)和符号引用(类和接口的全限定名、字段的名称和描述符、方法的名称和描述符)。

![常量池结构示例图](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/2021-06-22-15-53-55.png)
![class常量池相关属性结构](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/2021-06-22-15-55-31.png)

#### 运行时常量池

运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。
运行时常量池也是每个类都有一个, 运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。

## 帧(Frames)

帧用于存储数据和部分结果，以及执行动态链接、方法返回值和分派异常。

每次调用方法时都会创建一个新的帧。当方法调用完成时，帧将被销毁，不管该完成是正常的还是突然的(它将引发未捕获的异常)。帧是从创建框架的线程的 Java 虚拟机堆栈中分配的。每个帧都有自己的局部变量数组、自己的操作数堆栈 ，以及对当前方法类的运行时常量池的引用。

在给定的控制线程中，只有一个帧(执行方法的帧)处于活动状态。这个帧称为当前帧，它的方法称为当前方法。定义当前方法的类是当前类。对局部变量和操作数堆栈的操作通常与当前帧有关。

为程序提供调试功能

### 局部变量

每个帧包含一个变量数组，称为其局部变量。帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式提供，同时提供与帧相关联的方法的代码。

索引访问

单个局部变量可以保存类型为 boolean、 byte、 char、 short、 int、 float、 reference 或 returnAddress 的值。一对局部变量可以保存 long 或 double 类型的值。

### 操作数栈(Operand Stacks)

每个帧包含一个后进先出(LIFO)堆栈，称为其操作数堆栈。帧的操作数堆栈的最大深度在编译时确定。

操作数堆栈上的每个条目都可以保存任何 Java 虚拟机类型的值，包括 long 类型或 double 类型的值。

操作数堆栈中的值必须以适合其类型的方式进行操作。

在任何时间点，操作数堆栈都有一个相关的深度，其中 long 或 double 类型的值为深度贡献两个单位，其他类型的值为深度贡献一个单位。

### 动态链接(Dynamic Linking)

每个帧包含对当前方法类型的运行时常量池的引用，以支持方法代码的动态链接。方法的类文件代码引用要调用的方法和要通过符号引用访问的变量。动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移量。

### 正常方法调用完成(Normal Method Invocation Completion)

如果调用不会直接从 Java 虚拟机引发异常(2.10) ，或者由于执行显式抛出语句而引发异常，则方法调用正常完成。如果当前方法的调用正常完成，则可以将值返回给调用方法。当被调用的方法执行一条返回指令(2.11.8)时，就会发生这种情况，选择哪一条指令必须适合所返回值的类型(如果有的话)。

在这种情况下，使用当前帧(2.6)恢复调用程序的状态，包括其局部变量和操作数堆栈，调用程序的程序计数器适当地递增以跳过方法调用指令。然后在调用方法的框架中继续正常执行，将返回的值(如果有的话)推送到该框架的操作数堆栈上。

### 方法调用的突然完成(Abrupt Method Invocation Completion)

如果在方法中抛出异常，并且该异常没有在方法中处理，则方法调用会突然完成。会显式引发异常，如果当前方法没有捕获异常，则会导致突然的方法调用完成。突然完成的方法调用永远不会向其调用程序返回值。

### 帧其它相关

1. 浮点运算
   1. JVM 的浮点操作
      - 遇到被0除、上下限溢出和非精确时，不会抛出错误
      - 不支持 IEEE 754 的信号浮点比较
      - 舍入操作：向最接近数舍入模式，如果无法精确，则舍入到最低有效位为 0 的那个值
      - 浮点数值 -> 整型数值：向零舍入
      - 不支持 IEEE 754 的单精度扩展和双精度扩展格式
   2. 浮点模式
      - 每个方法都有这项属性
      - 分为 FP-strict 模式、非FP-strict模式
      - 体现在 class 文件的方法 method_info 结构的访问标志 access_flags 中的 ACC_STRICT 标志位
      - JDk 1.1以及之前版本的编译器是 非FP-strict模式
   3. 数值集合转换
      - 支持扩展指数集合的 JVM 实现数值在标准浮点数集合与扩展指数集合之间饿映射关系是允许或必要的
      - float => 单精度浮点数集合中的元素
      - double => 双精度浮点数集合中的元素
2. 特殊方法
   （1） 构造方法（初始化方法）
   （2）签名多态性
   由 java.lang.invoke.MethodHandle 类进行声明
   只有一个类型为 Object[] 的形参
   返回值为 Object
   ACC_VARARGS 和 ACC_NATIVE 标志被设置
3. 异常
   1. 同步异常
      athrow 字节码指令被执行
      虚拟机同步检测到程序发生非正常的执行情况
   2. 异步异常
      调用了 Thread 或者 ThreadGroup 的 stop 方法
      JVM 实现发生了内部错误
      每个执行的方法都配备0~多个异常处理器
4. 类库
   需要JVM特殊支持的类
   反射：java.lang.reflect、Class
   加载和创建类或接口的类：ClassLoader
   连接和初始化类或接口：ClassLoader
   安全：java.security
   多线程：Thread
   弱引用：java.lang.ref
5.  公有设计、私有实现
   == 统一设计、各自实现
