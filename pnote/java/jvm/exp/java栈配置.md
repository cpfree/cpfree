---
keys: 
type: trim
url: <https://blog.csdn.net/qq_34805255/article/details/100799637>,<https://blog.csdn.net/qq_31331965/article/details/102465589>
id: 220206-173927
---

# java 栈与递归

## 栈 与方法调用

每一个方法调用时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息.

但是虚拟机栈一般是运行在一级或二级缓存里面的, 因此速度非常快.

## 栈与堆的对比分析

> AI象棋JVM调优时感悟

当栈的`空间量级`为常数级别时, 堆得`空间量级`为乘数级, 当栈的`空间量级`为加数级别时, 堆的`空间量级`为指数级.

## 栈溢出

但方法调用层级太深的时候, 就会发生栈溢出.

> 《深入了解JVM》一书中说到：当线程请求的栈深度超过虚拟机允许的栈深度时，便会抛出StackOverFlowError

至于怎么溢出, 还要看不同的JVM虚拟机实现.

## 一个栈帧有多大

编译时，栈帧需要多大的局部变量表、多深的操作数栈都已经完全确定，并且写入到方法表的Code属性中，因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现

一般而言, 一个简单的方法, 如下, 在 64位的虚拟机, `-Xss` 的值设置为`100k`的情况下, 栈的大小也就差不多`1000`的情况下就差不多栈溢出了.

```java

private static int c1 = 0;

public static void fun() {
	c1++;

	fun();
}

```


## JVM 栈配置

栈大小是可以通过参数（-Xss）设置的, 栈是线程私有的，线程内部的每个方法调用会创建一个栈帧，所以如果“栈帧的数量*每个栈帧的大小>栈大小”时便会发生“栈溢出”。

-Xss设置的参数是针对每一个栈的，而非JVM所有线程栈内存总大小。

在x64位Linux操作系统上，JVM默认的栈大小为1024kb。

## 栈与递归

1. 方法调用层级不要太深

   当然一般来说, 哪怕是一个很大的项目调用层级一般也不会超过100层, 也就表示说, 一般来说栈的空间大小一般100也就够用了.

2. 一般情况下, 能造成栈溢出的也就是, 死循环, 或者是递归调用.

   循环调用和递归调用, 会极大的增加栈深度.

   通常死循环完全就是bug级别的存在, 从代码角度解决以下就好.

   > 而一般递归调用也不会太大的, 但是就是有一些人使用递归做一些另类的事情.
   > 例如有一道题, 就是`如何逆序输出一个单向链表`, 然后解决方法里面居然有递归, 若是单向链表大小超过`10000`, 那不是要栈溢出了.
   >
   > 一般对大型集合遍历的话, 最好不要用递归（深度优先遍历）
