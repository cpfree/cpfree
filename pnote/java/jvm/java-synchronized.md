# synchronized

1. synchronized 能同时保证可见性，原子性，有序性, 但是相对来说 synchronized 较重, 耗费资源较多.
2. synchronized 使用时锁住的对象
   | **sychronized 使用** | **锁**              |
   | -------------------- | ------------------- |
   | **修饰静态方法**     | **当前 class 对象** |
   | **修饰实例方法**     | **当前实例对象**    |
   | **修饰对象**         | **修饰的对象**      |

3. synchronized 涉及到偏向锁,轻量级锁,自旋锁,CAS,重量级锁(对象锁)

### synchronized相关底层信息存放位置

   锁住的对象存放在该对象的对象头里面的markword里面

   ![markword对象内容](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1638190243286-bf4d9b57-cc2c-41af-a523-0e321e53a983.png)

   ```c
   ObjectMonitor() {
      _count        = 0; //记录数
      _recursions   = 0; //锁的重入次数
      _owner        = NULL; //指向持有ObjectMonitor对象的线程 
      _WaitSet      = NULL; //调用wait后，线程会被加入到_WaitSet
      _EntryList    = NULL ; //等待获取锁的线程，会被加入到该列表
   }
   ```

### synchronized锁优化:偏向锁,轻量级锁,自旋锁

早期 synchronized 重量级锁在资源竞争时太浪费资源, 因此在 jdk 1.6 版本引入了偏向锁和轻量级锁.

   > Doug Lea一个类的效率都比 synchronized 重量级锁的效率高，

**几个锁的的相关信息**

   1. 偏向锁(since 1.6)
      适用 ：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
      依据 : 在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得.
      方式 : 如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，
      升级为轻量级锁条件 : 多个线程获取一把锁

   2. 轻量级锁(since 1.6)
      适用 ：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
      依据 : 对绝大部分的锁，在整个同步周期内都不存在竞争(线程交替执行同步块, 同一时间不会获取同一把锁),
      目标 : 减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。
      方式 : 轻量级锁时，不需要申请互斥量，仅仅将 Mark Word 中的部分字节 CAS 更新指向线程栈中的 Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；
      升级为重量级锁条件 : 多个线程同一时间访问同一锁

   3. 重量级锁
      适用 ：有实际竞争，且锁竞争时间长。
      重量级锁就是一般我们说的**对象锁**.

   4. 自旋锁
      轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
      依据 : 在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起, 时间成本相对较高，
      因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是 50 个循环或 100 循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

   5. 锁消除
      Java 虚拟机在 JIT 编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，去除不可能存在共享资源竞争的锁，
      eg : StringBuffer 的 append 是一个同步方法，但是在 add 方法中的 StringBuffer 属于一个局部变量，并且不会被其他线程所使用，因此 StringBuffer 不可能存在共享资源竞争的情景，JVM 会自动将其锁消除。

锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从 `偏向锁`升级到 `轻量级锁`，再升级的 `重量级锁`(升级是单向的)，

### synchronized锁优化: 锁升级步骤

**偏向锁升级步骤**:

1. 首先当线程获取到🔒之后, 将当前线程ID放到🔒对象的markword里面, 偏向锁后续不会主动释放锁.
2. 当下一个线程来之后会比较当前线程的threadID和Java对象头中的threadID是否一致.
   - 如果一致: 直接获取锁, 无需再有加锁或者解锁步骤
   - 若不一致: 查看Java对象头中记录的线程1是否存活.
      - 如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；
      - 如果存活，那么立刻查找该线程（线程1）的栈帧信息
         - 如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。
         - 如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁.

**轻量级锁升级步骤**

1. 线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；

2. 如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用**自旋锁**来等待线程1释放锁。 
   
3. 自旋锁简单来说就是让线程2在循环中不断CAS, 自旋是要消耗CPU的，因此自旋的次数是有限制的，比如50次或者100次.如果接下来出现以下情况轻量级锁, 会转为重量级锁
   1. 如果自旋次数到了线程1还没有释放锁
   2. 线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象.

4. 升级为重量级锁的时候, 重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

### synchronized 的可重入性

可重入性 : 一个线程得到一个对象锁后再次请求该对象锁(eg : 在一个线程调用 synchronized 方法的同时在其方法体内部调用该对象另一个 synchronized 方法).

> 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在 java 中 synchronized 是基于原子性的内部锁机制，是可重入的，
> 当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于 synchronized 是基于 monitor 实现的，因此每次重入，monitor 中的计数器仍会加 1。

### interrupt(线程中断与 synchronized)

```java
//中断线程（实例方法）
public void Thread.interrupt();
//判断线程是否被中断（实例方法）
public boolean Thread.isInterrupted();
//判断是否被中断并清除当前中断状态（静态方法）
public static boolean Thread.interrupted();
```

当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用 Thread.interrupt()方式中断该线程，注意此时将会抛出一个 InterruptedException 的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，

事实上线程的中断操作对于正在等待获取的锁对象的 synchronized 方法或者代码块并不起作用，也就是对于 synchronized 来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。

### 等待唤醒机制(notify/notifyAll 和 wait)

- 调用 notify/notifyAll 和 wait 方法前必须拿到当前对象的监视器 monitor 对象，因此必须处于 synchronized 代码块或者 synchronized 方法中，否则就会抛出 IllegalMonitorStateException 异常，
- wait 方法调用完成后，线程将被暂停，但 wait 方法将会释放当前持有的监视器锁(monitor)，直到有线程调用 notify/notifyAll 方法后方能继续执行，
- notify/notifyAll 方法调用后，并不会马上释放监视器锁，而是在相应的 synchronized(){}/synchronized 方法执行结束后才自动释放锁。
