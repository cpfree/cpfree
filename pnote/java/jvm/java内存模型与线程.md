---
keys: jvm,线程,jmm,内存模型
type: copy,blog,trim
url: <>
id: 211125-203748
---
## java内存模型

1. java内存模型

   Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了 `成员变量`和 `静态变量`以及 `构成数组对象的元素`，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享

   ![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1637931925718.png)

   > 这里所讲的主内存、工作内存Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分.
   >
   > 从java虚拟机来看，`主内存`主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。
   > 从硬件角度来看，`主内存`直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。
   >
2. JMM中内存之间的交互操作

   1. 8个原子操作

   - lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
   - unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
   - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
   - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
   - use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
   - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
   - store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
   - write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

   ![img](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1637931909745.png)

   除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：

   - 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。_注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的_
   - 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
   - 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
   - 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。
   - 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
   - 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。
   - 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
   - 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

   这8种内存访问操作以及上述规则限定，再加上稍后会介绍的专门针对volatile的一些特殊规定，就已经能准确地描述出Java程序中哪些内存访问操作在并发下才是安全的。

   这种定义相当严谨，但也是极为烦琐，实践起来更是无比麻烦。_我们只需要理解Java内存模型的定义即可。_
