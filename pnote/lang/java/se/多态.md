---
keys: java,多态
type: copy,blog,trim
url: <https://blog.csdn.net/ruihaol/article/details/52965160>
---

# 多态

1. this.tag 并不单单指向本类的 tag 对象, 若本类里面没有 tag 对象, `this.tag` 还可以到继承链中逐级查找其超类的 tag, 逐层递进
2. 方法级的 `public static final` 中的 `final` 是有用的, 可以防止之类方法重新声明
3. 静态方法是不能添加 `@Override` 的
4. 在类中的非静态方法级里面的代码运行时需要依靠外界的一个类对象, 此时可以使用 this, super 关键字, 也可以使用外层类的 ClassName.this, ClassName.super 关键字.

## 重写(Overriding)

## 重载(Overloading)

### 超类引用子类对象

**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。**

> `超类对象引用变量引用子类对象时`, `超类对象引用`是`引用对象的类型`, `子类对象`是`被引用变量的类型`
> 
> 继承链中方法调用的优先级为：
> 1. 先在本类找同参数方法
> 2. 顺着继承链找同参数方法
> 3. 在本类找父参数方法
> 4. 顺着继承链找父参数方法
> 简而言之就是 this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。

```java
Father f = new Son();
f.test()
```

简单来说就是调用分为两步

1. 由引用对象决定调用方法
   如果没有涉及到**重载**就简单了, 只能找到一个(找不到的话编译不会通过的).
   如果涉及到**重载**, 则在`Father`类基础上按照继承链方法调用优先级查找方法.
2. 确定调用谁的成员方法
   确定调用的方法之后, 看下`Father`类到`Son`类段的继承链是否有重写该方法, 如果重写, 则调用继承链最终重写的方法.

以下参考题目来源于网络：

   ```java
   class A {
      public String show(D obj){
         return ("A and D");
      }

      public String show(A obj){
         return ("A and A");
      }
   }

   class B extends A{
      public String show(B obj){
         return ("B and B");
      }

      public String show(A obj){
         return ("B and A");
      }
   }

   class C extends B{}

   class D extends B{}

   @Test
   public void main() {
      A a1 = new A();
      A a2 = new B();
      B b = new B();
      C c = new C();
      D d = new D();
      A a3 = new D();

      System.out.println("1--" + a1.show(b));
      System.out.println("2--" + a1.show(c));
      System.out.println("3--" + a1.show(d));
      System.out.println("4--" + a2.show(b));
      System.out.println("5--" + a2.show(c));
      System.out.println("6--" + a2.show(d));
      System.out.println("7--" + b.show(b));
      System.out.println("8--" + b.show(c));
      System.out.println("9--" + b.show(d));
      System.out.println("10--" + a3.show(b));
   }
   ```

运行结果

   ```log
   1--A and A
   2--A and A
   3--A and D
   4--B and A
   5--B and A
   6--A and D
   7--B and B
   8--B and B
   9--A and D
   10--B and A
   ```