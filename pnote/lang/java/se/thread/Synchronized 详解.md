#### Java虚拟机对synchronized的优化
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。
随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁(升级是单向的)，

1. 偏向锁(since 1.6)
适用 ：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
依据 : 在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得.
方式 : 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，
升级为轻量级锁条件 : 多个线程获取一把锁

2. 轻量级锁(since 1.6)
适用 ：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
依据 : 对绝大部分的锁，在整个同步周期内都不存在竞争(线程交替执行同步块, 同一时间不会获取同一把锁),
目标 : 减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。
方式 : 轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；
升级为重量级锁条件 : 多个线程同一时间访问同一锁

3. 重量级锁
适用 ：有实际竞争，且锁竞争时间长。


4. 自旋锁
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
依据 : 在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起, 时间成本相对较高，
因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

5. 锁消除
Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，去除不可能存在共享资源竞争的锁，
eg : StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。


### synchronized的可重入性
可重入性 : 一个线程得到一个对象锁后再次请求该对象锁(eg : 在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法).
>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，
当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。

### interrupt(线程中断与synchronized)
```java
//中断线程（实例方法）
public void Thread.interrupt();
//判断线程是否被中断（实例方法）
public boolean Thread.isInterrupted();
//判断是否被中断并清除当前中断状态（静态方法）
public static boolean Thread.interrupted();
```
当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，
事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。

### 等待唤醒机制(notify/notifyAll和wait)
- 调用notify/notifyAll和wait方法前必须拿到当前对象的监视器monitor对象，因此必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，
- wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，
- notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁。
