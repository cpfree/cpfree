> [ClassLoader加载机制](https://www.cnblogs.com/ITtangtang/p/3978102.html)

## 概述

Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。
虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

### 工作原理

类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：

   1. 装载：查找和导入Class文件；
      (1) 通过一个类的全限定名来获取定义此类的二进制字节流.
      (2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构.
      (3) 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
      虚拟机规范中并没有准确说明二进制字节流应该从哪里获取以及怎样获取,这里可以通过定义自己的类加载器去控制字节流的获取方式。

   2. 链接：把类的二进制数据合并到JRE中；
      1. 校验：检查载入Class文件数据的正确性；
      2. 准备：给类的静态变量分配存储空间；
         准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配,需要说明的是：
         这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中;这里所说的初始值“通常情况”是数据类型的零值，假如:
         public static int value = 123;
         value在准备阶段过后的初始值为0而不是123,而把value赋值的putstatic指令将在初始化阶段才会被执行.
      3. 解析：将符号引用转成直接引用；
   3. 初始化：对类的静态变量，静态代码块执行初始化操作

#### 类加载器

1. BootStrap ClassLoader(C++ 实现)
   负责加载系统类(jre/lib/rt.jar)
2. Extensive ClassLoader
   负责加载扩展类(jar/lib/ext/*.jar)
3. Application ClassLoader
   负责加载应用类(ClassPath指定的目录和jar中的类)
4. User ClassLoader(用户自定义类加载器)

#### 双亲委派模型
