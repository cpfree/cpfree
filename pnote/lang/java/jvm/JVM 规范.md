# [***JVM 规范小结***](https://yq.aliyun.com/articles/619813?utm_content=m_1000008975)

> https://blog.csdn.net/tonytfjing/article/details/44278233

# 一、基础

1. 与 Java 语言
   JVM 与 Java 语言没有必然的联系，只与 class 文件格式有关联。

2. 与 .class 文件
   - class 文件包含了 Java 虚拟机指令集（字节码）和符号表，以及其他辅助信息。
   - JVM 在 class 文件中施加了许多强制性语法和结构化约束。
   - 凡是能用 class 文件正确表达出来的编程语言都可以在 JVM 中执行。

3. 数据类型
   - 原始类型（基本类型），如 int、double、long <---> 原始值
         ① 整数类型
            byte 8位有符号二进制补码整数，默认值为0（下面3个也是）
            short 16位有...
            int 32位有...
            long 64位有...
            char 16位无符号整数表示的、指向基本多文种平面（BMP）的 Unicode 码点，UTF-16 编码，默认为 null（'u0000'）
         ② 浮点数类型
            float 32位单精度（IEEE 754标准）
            double 64位单精度（IEEE 754标准）
         **五个特殊数值**：正数0、负数0、正无穷大、负无穷大、NaN
         除了 NaN 之外，其他值都是 有序的
         有且仅有一个值 NaN 与自身比较返回 false
         任何数字与 NaN 比较都会返回 false
         ③ returnAddress
            值指向虚拟机一个地址
         ④ boolean
         在编译之后一般使用 int 数据类型代替

   - 引用类型，如 reference <---> 引用值
         class type
         array type
         interface type
         数据最外维是 组件类型，最里面维度称为 元素类型。如List，其中List是组件类型，Integer是元素类型。
         顺便一提，Integer具有一个缓冲池 -128~127，默认情况下直接从池中取值（取的值相等则变量地址相同），除非 new Integer(10) 或者取超出范围的值。
> JVM 希望类型检查能在程序运行前（编译阶段）完成。

## 运行时数据区

   1. pc 寄存器
      每个 JVM 线程都有自己的 pc 寄存器
      每个线程只执行一个方法
      容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值

   2. 虚拟机栈(VM stack)
      StackOverflowError 线程请求分配的栈容量超过 JVM 栈允许的最大容量
      OutOfMemoryError 栈可以动态扩展，在尝试扩展时无法申请到足够的内存

   3. 本地方法栈(native method stack)
      支持 native 的执行（其他语言编写的方法）
      抛出StackOverflowError
      抛出OutOfMemoreyError

   4. 堆(heap)
      是可供各个线程共享的 运行时内存区域
      是供所有类实例和数组对象 分配内存 的区域
      所使用的内存，不需要 保证是 连续 的
      抛出OutOfMemoryError

   5. 方法区(method area)
      是可供各个线程共享的 运行时内存区域
      包括【 运行时常量池，字段和方法数据，构造函数和普通方法的字节码内容，在类、实例、接口初始化时用到的特殊方法】
      抛出OutOfMemoryError

   6. 运行时常量池(存放在方法区种)
      class 文件中每一个类或接口的常量池表
      抛出OutOfMemoryError



4.Class文件常量池
       Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

这里的字面量是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分)；
符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用；
5.运行时常量池
       运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。

6.字符串常量池
       字符串常量池是全局的，JVM 中独此一份，因此也称为全局字符串常量池。运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。其实，“使用常量池”对应的字节码是一个 ldc 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。String 类的 intern() 方法还可在运行期间把字符串放到字符串常量池中。JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。其中：

在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例；
在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中；
jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用。


## 帧栈

   存储数据和部分过程结果的数据结构
   也用来处理动态链接、方法返回值和异常分派
   随着方法调用而创建，随着方法结束而销毁
   为程序提供调试功能
   当前栈帧 - 当前类 - 当前方法
   （1）局部变量表
      索引访问
      long 和 double 的值占用两个连续的局部变量
   （2）操作数栈
      long 和 double 占用两个单位的栈深度
   （3）动态链接
      每个栈帧都包含一个指向当前方法所在类型的运行时常量池的引用
      晚期绑定？

1. 浮点运算
   1. JVM 的浮点操作
      - 遇到被0除、上下限溢出和非精确时，不会抛出错误
      - 不支持 IEEE 754 的信号浮点比较
      - 舍入操作：向最接近数舍入模式，如果无法精确，则舍入到最低有效位为 0 的那个值
      - 浮点数值 -> 整型数值：向零舍入
      - 不支持 IEEE 754 的单精度扩展和双精度扩展格式
   2. 浮点模式
      - 每个方法都有这项属性
      - 分为 FP-strict 模式、非FP-strict模式
      - 体现在 class 文件的方法 method_info 结构的访问标志 access_flags 中的 ACC_STRICT 标志位
      - JDk 1.1以及之前版本的编译器是 非FP-strict模式
   3. 数值集合转换
      - 支持扩展指数集合的 JVM 实现数值在标准浮点数集合与扩展指数集合之间饿映射关系是允许或必要的
      - float => 单精度浮点数集合中的元素
      - double => 双精度浮点数集合中的元素
2. 特殊方法
   （1） 构造方法（初始化方法）
   （2）签名多态性
   由 java.lang.invoke.MethodHandle 类进行声明
   只有一个类型为 Object[] 的形参
   返回值为 Object
   ACC_VARARGS 和 ACC_NATIVE 标志被设置
3. 异常
   1. 同步异常
      athrow 字节码指令被执行
      虚拟机同步检测到程序发生非正常的执行情况
   2. 异步异常
      调用了 Thread 或者 ThreadGroup 的 stop 方法
      JVM 实现发生了内部错误
      每个执行的方法都配备0~多个异常处理器
4. 类库
   需要JVM特殊支持的类
   反射：java.lang.reflect、Class
   加载和创建类或接口的类：ClassLoader
   连接和初始化类或接口：ClassLoader
   安全：java.security
   多线程：Thread
   弱引用：java.lang.ref
5.  公有设计、私有实现
   == 统一设计、各自实现

---

## 垃圾收集器与内存分配策略

   java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。
   Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题

### 内存分配

   Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；

   java一般内存申请有两种：

   **静态内存** : 编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量.

   **动态内存** : 动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。

### 垃圾检测方法

1. 引用计数法 : 给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。
   优点：判定效率高，实现简单
   缺点：难以解决对象之间相互引用的问题

2. 可达性分析算法 : 以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象, 本地方法中引用的对象等。
   特点：GC Roots

### GC

#### GC 回收算法

1. 标记-清除（Mark-sweep）
   标记所有需要回收的对象，然后统一回收。
   不足：效率低；标记清除之后会产生大量碎片。效果图如下：
2. 复制（Copying）
   此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
   优点 : 复制成本比较小，不会出现“碎片”问题。
   缺点 : 就是需要两倍内存空间。
3. 标记-整理（Mark-Compact）
   堆内存分为两端, 标记所有被引用对象，遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的另一端，
4. 分代收集算法
   基于不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。将对象按其生命周期的不同划分成：年轻代(Young Generation, 年轻代分为一个 Eden区, 两个survive区(from, to 区))、年老代(Old Generation)、持久代(Permanent Generation)。其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。这里有个比喻很形象
   年轻代：是所有新对象产生的地方。年轻代被分为3个部分——Eden区和两个Survivor区（From和to）hotspot默认Eden : Survivor大小比例为8:1:1, Survivor的两个区是对称的，没先后关系，from和to是相对的。
   年老代：在年轻代中经历了N次回收后仍然没有被清除的对象, 通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
   持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。

   1. 当系统创建一个对象的时候，总是先在Eden区操作，
   2. 第一次Eden区满了就会触发一次YoungGC，也就是年轻代的垃圾回收, 将Eden区还在被使用的对象复制到From区
   3. 当Eden再区满了，那么再触发一次YoungGC，也就是年轻代的垃圾回收。将Eden区与From区还在被使用的对象复制到To区.
   4. 当Eden再区满了, 执行上一条, 在From与To之间来回游荡, From区和to区是相对的
   5. 经过若干次YoungGC后，这时候From区与To区亮出了底线（阈值），此时会将from或to区的对象移动至老年代。
   6. 若干次后, 老年代野蛮了, 执行集体大扫除（Full GC），也就是全量回收。

   > Full GC成本高，使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作

#### Minor & Major & Full GC

Minor GC : 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。
   > 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。
   > Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。

~Major GC~ : 是清理老年代。
Full GC  : 是清理整个堆空间—包括年轻代和老年代。
很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。

#### 永久代 & 方法区 & metaspace

涉及到内存模型时，往往会提到永久代，《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。因此，我们得到了结论，
永久代是HotSpot的概念，**方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现**，一个是标准一个是实现。其他的虚拟机实现并没有永久带这一说法。在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收:

对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间。它可永久代有什么不同的？存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。
在1.8中，可以使用如下参数来调节方法区的大小

-XX:MetaspaceSize 
元空间初始大小
-XX:MaxMetaspaceSize 
元空间最大大小
超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: Metadata space
在jdk1.7中抛出的异常是这样:java.lang.OutOfMemoryError: PermGen



   1. HotSpot 算法实现
      核心：根节点枚举，数据结构采用 OopMap
      在特定位置（安全点 SafePoint）记录
      安全区域（SafeRegion）：在一端代码片段之中，引用关系不会发生变化。在这个区域中的任一地方开始 GC 都是安全的
   2. 垃圾回收器
      新生代：Serial、ParNew、Parallel Scavenge
      老年代：CMS、Serial Old（MSC）、Parallel Old
      任意代：G1
      Serial 单线程
      ParNew 多线程版本的 Serial
1. CMS 收集器
   以获取最短回收停顿时间为目标的收集器；常用在互联网或者 B/S 系统的服务端上。【注重服务端的响应速度，希望系统停顿时间最短】

   过程
   初始标记 stw
   并发标记
   重新标记 stw
   并发清除
   缺点一：对 CPU 资源敏感
   i-CMS 增量式并发收集器，适用于CPU数量过少时，收集器线程资源占用率高的情况（已被 deprecated，效率低，不提倡使用）

   缺点二：无法处理浮动垃圾
   缺点三：使用标记 - 清除算法
2. G1 收集器
   > 面向服务端

   并行、并发
   分代收集
   空间整合
   可预测的停顿，建立可预测的停顿时间模型
   过程
   初始标记
   并发标记
   最终标记
   筛选回收
3. 内存分配与回收策略
   对象优先在新生代 Eden区分配，无空间时发起一次 Minor GC
   大对象直接进入老年代
   长期存活的对象将进入老年代（年龄计数器）
   动态对象年龄判断（年龄相对较大直接进入老年代）
   空间分配担保（老年代有足够空间容纳新生代）
4. 关于GC
   新生代：Minor GC
   老年代：Major GC 或 Full GC

---
### 三、内存模型与线程
   1. 优化
      指令重排序
   2. 内存间交互操作
      lock
      unlock
      use
      assign
      load
      store
      read
      write
   3. volatile
      所有线程可见
      禁止指令重排序优化（机器指令增加 lock）
   4. 先行发生关系
      程序次序规则
      管程锁定规则
      volatile 变量规则
      线程启动规则
      线程终止规则
      线程中断规则
      对象终结规则
      传递性
   5. 线程实现
      内核线程（需要系统调用：系统态<->用户态）
      用户线程
      用户线程 + 轻量级进程
      抢占式调度，而不是协同式调度变量
