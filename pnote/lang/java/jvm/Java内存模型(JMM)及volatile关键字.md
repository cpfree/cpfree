##[***全面理解Java内存模型(JMM)及volatile关键字***](https://blog.csdn.net/javazejian/article/details/72772461)

## TARGET

理解Java内存区域与Java内存模型
   Java内存区域
      - 有哪些内存区域, 哪些是共享, 那些是私有?
   Java内存模型概述(JMM)
硬件内存架构与Java内存模型
   硬件内存架构
   Java线程与硬件处理器
   Java内存模型与硬件内存架构的关系
JMM存在的必要性
   Java内存模型的承诺
   原子性
      理解指令重排
      编译器重排
      处理器指令重排
   可见性
   有序性
   JMM提供的解决方案
   理解JMM中的happens-before 原则
volatile内存语义
volatile的可见性
volatile禁止重排优化

### note

Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，
----

### Java内存区域

1. 方法区（Method Area）：
方法区属于线程共享的内存区域，主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。

2. JVM堆（Java Heap）：
Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。
3. 程序计数器(Program Counter Register)：
属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
4. 虚拟机栈(Java Virtual Machine Stacks)：
属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）：
5. 本地方法栈(Native Method Stacks)：
本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。

### Java内存模型概述

硬件内存架构与Java内存模型
硬件内存架构
Java线程与硬件处理器
Java内存模型与硬件内存架构的关系
JMM存在的必要性
Java内存模型的承诺
原子性
理解指令重排
编译器重排
处理器指令重排
可见性
有序性
JMM提供的解决方案
理解JMM中的happens-before 原则
volatile内存语义
volatile的可见性
volatile禁止重排优化
