# redis 数据类型

> 参考自: <https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247501112&idx=1&sn=e42b6c61c6747e2c2f3b890ab4e4b844>

Redis 底层的数据结构一共有 6 种

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644415603514.png)

| 数据类型 | 底层数据结构               |
| -------- | -------------------------- |
| String   | SDS                        |
| List     | `双向链表` or `压缩列表` |
| Hash     | `压缩列表` or `哈希表`     |
| Set      | `哈希表` or `整数集合`     |
| Zset     | `压缩列表` or `跳表`       |

## SDS

### 1. C语言字符串缺陷

C 语言字符串数据结构

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644670840165.png)

1. C语言字符串内容就是字符串+结束符号, 
2. C语言字符串引用是个指针, 指向字符串开头, C语言字符串结尾是个`\0`

以上结构使得C语言字符串有如下缺席

1. C语言字符串内容不能有`\0`, 因此也不能存放二进制数据(二进制数据里面难免有`\0`);
2. C语言获取字符串长度需要进行遍历, 不像其他语言字符串如`java字符串`
3. C语言字符串而且字符必须符合某种编码（比如ASCII）,如window若不支持UTF-8, 那么C语言也将不支持.
4. 字符串操作函数不高效且不安全，比如可能会发生缓冲区溢出，从而造成程序运行终止；

### SDS 结构设计

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644553014805.png)

`len`: SDS 所保存的字符串长度。这样获取字符串长度的时候，只需要返回这个变量值就行。

`alloc`，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算 出剩余的空间大小，然后用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区益处的问题。

`flags`: SDS 类型，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。

`buf[]`: 字节数组，字节数组会更好点。

字符串修改和扩容

   1. 修改时, 可以先通过`alloc - len`计算出剩余空间大小, 这样做改变的时候, 可以事先通过简单的计算就知道空间是否够用.
   2. 扩展SDS空间时, 还会检查未使用的空间是否足够, 若不够, 则不仅分配当前可用的空间,还会分配额外的未使用空间.
   3. 扩展SDS空间时, 若有未分配的额外空间, 则会优先使用这部分额外的空间.

设计优点:

   1. 可以存放byte数组
   2. 有内存分配大小的元数据, 可以防止缓冲区溢出.

> attribute 可以配置紧凑的内存空间分配

### 链表

C++里面没有链表设计, Redis里面设计了一个双向列表.

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644557439756.png)

```c
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

Redis里面设计了一个双向列表. 同时也是无环列表.

链表缺陷: 链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存, 能很好利用 CPU 缓存的数据结构就是数组

#### 压缩列表

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644557597439.png)

- zlbytes，记录整个压缩列表占用对内存字节数；
- zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；用来快速定位到尾部元素
- zllen，记录压缩列表包含的节点数量；节点长度
- zlend，标记压缩列表的结束点，特殊值 OxFF（十进制255）。循环判断是否到达了尾部.

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644557746515.png)

压缩列表节点包含三部分内容：

prevlen，记录了前一个节点的长度；
encoding，记录了当前节点实际数据的类型以及长度；
data，记录了当前节点的实际数据；

#### 压缩列表的连锁更新问题

压缩列表除了查找复杂度高的问题，压缩列表在插入元素时，如果内存空间不够了，压缩列表还需要重新分配一块连续的内存空间，而这可能会引发连锁更新的问题。

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644558297816.png)

压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；
·其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的；

## hash

能以 O(1) 的复杂度快速查询数据

解决哈希冲突的方式，有很多种。Redis 采用了链式哈希

#### redis rehash

Redis 会使用了两个全局哈希表进行 rehash。

1. 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；
2. 将「哈希表 1 」的数据迁移到「哈希表 2」 中；
3. 变更引用, 原来的hash表释放.
4. 然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备, (渐进式hash做准备)。

问题: 如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。

#### 渐进式 rehash

在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上；

1. 给「哈希表 2」 分配空间；
2. 在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上；
3. 随着处理客户端发起的哈希表操作请求数量越多，最终会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。

这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。

在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。

比如，查找一个 key 的值的话，先会在哈希表 1 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。

另外，在渐进式 rehash 进行期间，

新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。

#### rehash触发条件

rehash 的触发条件跟负载因子（load factor）有关系。

负载因子 = hash表内已保存的节点数量 / hash表大小

当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。
当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。


## 整数集合

```c
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```


整数集合是  Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。


整数集合的升级操作
整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。

整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。

因此，整数集合升级的好处是节省内存资源。

整数集合支持降级操作吗？不支持, 只能升级不能降级.

既然添加了一个大的元素, 后续还可能再增加大的元素.

## 跳表

Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。

Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。

```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```

跳表数据结构

```c
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;

    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```

### quicklist

