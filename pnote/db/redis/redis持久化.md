# redis 持久化

> <https://baijiahao.baidu.com/s?id=1682713097817867905&wfr=spider&for=pc>

## 持久化

redis提供了两种持久化的方式，分别是 `RDB（Redis DataBase）` 和 `AOF（Append Only File）`。

- RDB: 简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；

- AOF: 则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。

### RDB

RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。

RDB持久化过程

1. redis会单独创建（fork）一个子进程来进行持久化，
   主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。

2. redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。
   正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。

#### RDB 触发方式

RDB 的触发有三种机制，执行save命令；执行bgsave命令；在redis.config中配置自动化。

1. save命令

   Save 命令执行一个同步保存操作，保存成功时返回 OK。

   save 命令会阻塞当前的Redis服务器，在执行该命令期间，Redis无法处理其他的命令(主进程无法工作，客户端无法连接)，直到整个RDB过程完成为止.

   用于新机器上数据的备份还好, 如果用在生产上，那么简直是灾难，数据量过于庞大，阻塞的时间点过长。这种方式并不可取。

2. bgsave命令

   BGSAVE 命令执行之后立即返回 OK, 会单独创建（fork）一个子进程来进行持久化, 持久化保存到磁盘后，然后退出。

   redis主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。

   BGSAVE方式比较适合线上的维护操作

3. 配置 `redis.config`

   ![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644131927617.png)

   `save 300 10`: 意味着在 300 秒内如果有十次或以上的修改操作，那么就进行数据备份.
   `save ""` : 表示禁止掉数据持久化

几个在配置文件中与 RDB 持久化相关的系数

- stop-writes-on-bgsave-error：默认值为yes，即当最后一次 RDB 持久化保存文件失败后，拒绝接收数据。这样做的好处是可以让用户意识到数据并没有被成功地持久化，避免后续更严重的业务问题的发生；
- rdbcompression：默认值为yes，即代表将存储到磁盘中的快照进行压缩处理；
- rdbchecksum：默认值为yes，在快照存储完成后，我们还可以通过CRC64算法来对数据进行校验，这会提升一定的性能消耗；
- dbfilename：默认值为dump.rdb，即将快照存储命名为dump.rdb；
- dir：设置快照的存储路径。

#### COW机制

先前提到了Redis为了不阻塞线上业务，所以需要一边持久化一边响应客户端的请求，因此fork出一个子进程来处理这些保存工作。那么具体这个fork出来的子进程是如何做到使得Redis可以一边做持久化操作，一边做响应工作呢？这就涉及到COW (Copy On Write)机制，那我们具体讲解以下这个COW机制。

Redis在持久化的时候会去调用`glibc`的函数fork出一个子进程，快照持久化完成交由子进程来处理，父进程继续响应客户端的请求。

而在子进程刚刚产生时，它其实使用的是父进程中的代码段和数据段。所以fork之后，`kernel`会将父进程中所有的内存页的权限都设置为read-only，然后子进程的地址空间指向父进程的地址空间。

当父进程写内存时，CPU硬件检测到内存页是read-only的，就会触发页异常中断（page-fault），陷入 kernel 的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。而此时子进程相应的数据还是没有发生变化，依旧是进程产生时那一瞬间的数据，故而子进程可以安心地遍历数据，进行序列化写入磁盘了。

随着父进程修改操作的持续进行，越来越多的共享页面将会被分离出来，内存就会持续增长，但是也不会超过原有数据内存的两倍大小（Redis实例里的冷数据占的比例往往是比较高的，所以很少出现所有页面都被分离的情况）。

COW机制的好处很明显：首先可以减少分配和复制时带来的瞬时延迟，还可以减少不必要的资源分配。但是缺点也很明显：如果父进程接收到大量的写操作，那么将会产生大量的分页错误（页异常中断page-fault）。

#### RDB 优缺点

优点: 

   RDB 是一个非常紧凑（compact）的文件（保存二进制数据），它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本；

   RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心；

   RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作；

   RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

劣势：

   RDB属于全量备份, 速度慢, 可能会至少 5 分钟才能完成一次 RDB 文件保存。 在这种情况下， 一旦发生故障停机， 就可能会丢失好几分钟的数据。

   如果数据量过大, `fork()` 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。

   RDB 会损失一些日志数据信息.

### AOF

AOF，英文是Append Only File，即只允许追加不允许改写的文件。

AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单.

服务器重新启动时，Redis就会利用 AOF 日志中记录的这些操作从新构建原始数据集。

Redis会在收到客户端修改指令后，进行参数修改、逻辑处理，如果没有问题，就立即将该指令文本存储到 AOF 日志中，也就是说，**先执行指令才将日志存盘**。这点不同于 leveldb、hbase等存储引擎，它们都是先存储日志再做逻辑处理。

我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。

#### AOF 的触发配置

AOF也有不同的触发方案，这里简要描述以下三种触发方案：

- always：每次发生数据修改就会立即记录到磁盘文件中，这种方案的完整性好但是IO开销很大，性能较差；

- everysec：在每一秒中进行同步，速度有所提升。但是如果在一秒内宕机的话可能失去这一秒内的数据；

- no：默认配置，即不使用 AOF 持久化方案。

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644132887327.png)

#### AOF 重写机制

随着Redis的运行，AOF的日志会越来越长，如果实例宕机重启，那么重放整个AOF将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr 一千次，那么就不需要去记录这1000次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。

同样的也可以在redis.config中对重写机制的触发进行配置：通过将no-appendfsync-on-rewrite设置为yes，开启重写机制；auto-aof-rewrite-percentage 100意为比上次从写后文件大小增长了100%再次触发重写；

auto-aof-rewrite-min-size 64mb意为当文件至少要达到64mb才会触发制动重写。

重写也是会耗费资源的，所以当磁盘空间足够的时候，这里可以将 64mb 调整更大写，降低重写的频率，达到优化效果。

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644133021522.png)

在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。

**bgrewriteaof指令**

   Redis 提供了bgrewriteaof指令用于对AOF日志进行重写.

   1. 该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为恢复现有数据的最少的命令集.
   2. 序列化到一个日志文件中。
   3. 完成后再替换原有的AOF文件，至此完成。

**重写机制**

   在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。

   与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。

   当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。

   当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。

#### AOF文件损毁

如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：

1. 如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。
   1. 备份被写坏的AOF文件
   2. 运行redis-check-aof –fix进行修复
   3. 用diff -u来看下两个文件的差异，确认问题点
   4. 重启redis，加载修复后的AOF文件

2. 在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。

#### fsync 函数

将AOF配置为appendfsync everysec之后，Redis在处理一条命令后，并不直接立即调用write将数据写入 AOF 文件，而是先将数据写入AOF buffer（server.aof_buf）。调用write和命令处理是分开的，Redis只在每次进入epoll_wait之前做 write 操作。

#### AOF 优缺点

优点
   AOF 持久化的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多也只会丢失掉一秒钟内的数据；

   AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

   Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

   AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

AOF 的缺点

   对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
   根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以   提供更有保证的最大延迟时间（latency）。
   AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。

### 混合持久化

对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。

重启 Redis 时，如果使用 RDB 来恢复内存状态，会丢失大量数据。而如果只使用 AOF 日志重放，那么效率又太过于低下。

Redis 4.0 提供了混合持久化方案，将 RDB 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自 RDB 持久化开始到持久化结束这段时间发生的增量 AOF 日志，通常这部分日志很小。

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1644133593078.png)

于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志，就可以完全替代之前的 AOF 全量重放，重启效率因此得到大幅提升。
