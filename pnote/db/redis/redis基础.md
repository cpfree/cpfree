# Redis(remote dictionary server)

## base

### redis 简介

Redis 是一个`基于内存`的高性能`key-value`数据库, 整个数据库统统加载在内存当中进行操作, 定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。

### redis 特点　　

Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。

Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。

### 优点

1. **速度快**，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1).
2. **支持丰富数据类型**: 支持 string，list，set，sorted set，hash.
3. **支持多种编程语言**: 
4. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行.
5. 持久化
6. 内存淘汰: 按 key 设置过期时间，过期后将会自动删除.
7. 丰富的特性：可用于缓存，消息，
8. 发布订阅: 
9. 管道
10. Lua
11. 集群、分布式

## redis 常见性能问题和解决方案

### 缓存击穿

### 缓存雪崩

### 缓存穿透

1. Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。

2. Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。

3. Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。

4. Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内.

5. mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据.

### redis 回收策略

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6 种数据淘汰策略：

| strategy             | means                                                                        |
| -------------------- | ---------------------------------------------------------------------------- |
| volatile-lru         | 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 |
| volatile-ttl         | 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰     |
| volatile-random      | 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰           |
| allkeys-lru          | 从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰                    |
| allkeys-random       | 从数据集（server.db[i].dict）中任意选择数据淘汰                              |
| no-enviction（驱逐） | 禁止驱逐数据                                                                 |

8.请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。具体登录函数或功能用空函数即可，不用详细写出。

用列表实现:列表中每个元素代表登陆时间,只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆.用 Python 写的代码如下：

   ```python
   #!/usr/bin/env python3
   import redis
   import sys
   import time

   r = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0)
   try:
      id = sys.argv[1]
   except:
      print(‘input argument error’)
      sys.exit(0)
   if r.llen(id) >= 5 and time.time() – float(r.lindex(id, 4)) <= 3600:
      print(“you are forbidden logining”)
   else:
      print(‘you are allowed to login’)
      r.lpush(id, time.time())
      # login_func()
   ```

9.为什么 redis 需要把所有数据放到内存中?

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。

如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

10.Redis 是单进程单线程的

redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

11.redis 的并发竞争问题如何解决?

Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在 Jedis 客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是

由于客户端连接混乱造成。对此有 2 种解决方法：

1.客户端角度，为保证每个客户端间正常有序与 Redis 进行通信，对连接进行池化，同时对客户端读写 Redis 操作采用内部锁 synchronized。

2.服务器角度，利用 setnx 实现锁。
　　　注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用 synchronized 也可以使用 lock；第二种需要用到 Redis 的 setnx 命令，但是需要注意一些问题。

12.redis 事物的了解 CAS(check-and-set 操作实现乐观锁 )?

和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在 Redis 中，MULTI/EXEC/DISCARD/WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出

Redis 中

事务的实现特征：
　　　　 1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。
　　　　 2). 和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。
　　　　 3). 我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为"BEGIN TRANSACTION"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行 EXEC/DISCARD 命令来提交/回滚该事务内的所有操作。这两

个 Redis 命令可被视为等同于关系型数据库中的 COMMIT/ROLLBACK 语句。
　　　　 4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。
　　　　 5). 当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。

Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部

分数据进行回滚。修复之后我们就可以再次重新启动 Redis 服务器了。

13.WATCH 命令和基于 CAS 的乐观锁：

在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set)功能。假设我们通过 WATCH 命令在事务执行之前监控了多个 Keys，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 Null multi-bulk 应答以通知调用者事务

执行失败。例如，我们再次假设 Redis 中并未提供 incr 命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：
　　 val = GET mykey
　　 val = val + 1
　　 SET mykey $val
　　以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。比如，客户端 A 和 B 都在同一时刻读取了 mykey 的原有值，假设该值为 10，此后两个客户端又均将该值加一后 set 回 Redis 服务器，这样就会导致 mykey 的结果为 11，而不是我们认为的 12。为了解决类似的问题，我们需要借助 WATCH 命令的帮助，见如下代码：
　　 WATCH mykey
　　 val = GET mykey
　　 val = val + 1
　　 MULTI
　　 SET mykey $val
　　 EXEC
　　和此前代码不同的是，新代码在获取 mykey 的值之前先通过 WATCH 命令监控了该键，此后又将 set 命令包围在事务中，这样就可以有效的保证每个连接在执行 EXEC 之前，如果当前连接获取的 mykey 的值被其它连接的客户端修改，那么当前连接的 EXEC 命令将执行失败。这样调用者在判断返回值后就可以获悉 val 是否被重新设置成功。

### redis 持久化的几种方式

1. 快照（snapshots）
   　　缺省情况情况下，Redis 把数据快照存放在磁盘上的二进制文件中，文件名为 dump.rdb。你可以配置 Redis 的持久化策略，例如数据集中每 N 秒钟有超过 M 次更新，就将数据写入磁盘；或者你可以手工调用命令 SAVE 或 BGSAVE。
   　　工作原理
   　　． Redis forks.
   　　． 子进程开始将数据写到临时 RDB 文件中。
   　　． 当子进程完成写 RDB 文件，用新文件替换老文件。
   　　． 这种方式可以使 Redis 使用 copy-on-write 技术。
2. AOF
   　　快照模式并不十分健壮，当系统停止，或者无意中 Redis 被 kill 掉，最后写入 Redis 的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，
   　　 Redis 就不是一个合适的选择。
   　　 Append-only 文件模式是另一种选择。
   　　你可以在配置文件中打开 AOF 模式
3. 虚拟内存方式
   　　当你的 key 很小而 value 很大时,使用 VM 的效果会比较好.因为这样节约的内存比较大.
   　　当你的 key 不小时,可以考虑使用一些非常方法将很大的 key 变成很大的 value,比如你可以考虑将 key,value 组合成一个新的 value.
   　　 vm-max-threads 这个参数,可以设置访问 swap 文件的线程数,设置最好不要超过机器的核数,如果设置为 0,那么所有对 swap 文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.

自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库

15. redis 的缓存失效策略和主键失效机制

作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略.
　　在 Redis 当中，有生存期的 key 被称为 volatile。在创建缓存时，要为给定的 key 设置生存期，当 key 过期的时候（生存期为 0），它可能会被删除。
　　 1、影响生存时间的一些操作
　　生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改 key 对应的 value 和使用另外相同的 key 和 value 来覆盖以后，当前数据的生存时间不同。
　　比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。
　　 RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个 persistent key 。
　　 2、如何更新生存时间
　　可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在 1ms 之内，主键失效的时间复杂度是 O（1），
　　 EXPIRE 和 TTL 命令搭配使用，TTL 可以查看 key 的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
　　最大缓存配置
　　在 redis 中，允许用户设置最大使用内存大小
　　 server.maxmemory
　　默认为 0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使 redis 崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。
　　 redis 提供 6 种数据淘汰策略：
　　． volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
　　． volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
　　． volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
　　． allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
　　． allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
　　． no-enviction（驱逐）：禁止驱逐数据
　　注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。
　　使用策略规则：
　　 1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
　　 2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random
　　三种数据淘汰策略：
　　 ttl 和 random 比较容易理解，实现也会比较简单。主要是 Lru 最近最少使用淘汰策略，设计上会对 key 按失效时间排序，然后取最先失效的 key 进行淘汰


### redis 为什么这么快

单机的 redis 就可以支撑每秒 10 几万的并发，相对于 mysql 来说，性能是 mysql 的几十倍。其速度快的原因主要有以下几点：

1. C语言实现
2. 采用高效的优化过的数据结构（C语言实现），在几种基础的数据结构上，redis 做了大量优化，性能极高；
3. 完全内存操作
4. 单线程运行, 没有上下文切换
5. 非阻塞IO多路复用机制.
6. 惰性删除.

### Redis 的底层数据结构一共有6种，分别为：简单动态字符串(SDS)，双向链表，压缩列表，哈希表，跳表和整数数组；

![](image/redis基础/1644415603514.png)


1、何谓高效的数据结构？
Redis 的底层数据结构一共有6种，分别为：简单动态字符串(SDS)，双向链表，压缩列表，哈希表，跳表和整数数组；
它们和数据类型的对应关系如下图：

简单动态字符串SDS：

redis 没有直接使用传统的 C 语言字符串类型，而是自己实现了一种叫做简单动态字符串 SDS 的抽象字符串类型。
C 语言的字符串并不会记录自身的长度信息，而 SDS 则保存了长度信息，这样就将获取字符串长度的时间复杂度由 O(N) 降低到了 O(1)，同时减少了修改字符串长度时所需的内存重分配次数。

双向链表 linkedlist：

redis 链表是一个双向无环链表结构，许多功能都采用链表来实现，如：发布、订阅、慢查询、监视器等；每个链表的节点由一个 listNode 结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点均指向 NULL。

哈希表 hashtable：

用于保存键值对数据的的抽象结构。redis 使用 hash 表作为底层实现，每个字典带有两个 hash 表，供平时使用和 rehash；
hash 表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对 hash 表进行扩容或者缩容的时候，为了服务可用性，rehash 过程不是一次性完成的，而是渐进式的。

跳跃表 skiplist：

跳跃表是有序集合的底层实现之一，redis 中在实现有序集合键和集群节点的内部结构中都用到了跳跃表。
redis 跳跃表由 zskiplist 和 zskiplistNode 组成。
zskiplist 用于保存跳跃表信息（表头、表尾节点、长度等）；
zskiplistNode 用于表示表跳跃节点，每个跳跃表的层高都是 1-32 的随机数；
在同一个跳跃表中，多个节点可以包含相同分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。

整数数组 intset：

用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。

压缩列表 ziplist：

压缩列表是为了节约内存而开发的【顺序性】数据结构，可以包含多个节点，每个节点可以保存一个字节数组或整数值。

基于以上6种基础数据结构，redis 封装了自己的对象系统，包含字符串对象 string、列表对象 list、哈希对象 hash、集合对象 set、有序集合对象 zset等，每种对象都用到了至少一种基础数据结构。

关于 Redis 的底层数据结构，其实单开一篇文章都讲不完，所以这里只是简单说明一下，后续会根据每种类型单独开讲。

待续……

注：redis6.0 之后其实已经改用多线程了，但并非是完全摒弃单线程，redis 依然使用单线程模型来处理客户端请求，只是使用多线程来处理数据的读写和协议解析。
这样做的目的是因为 redis 的性能瓶颈在于网络 IO 而非 CPU，使用多线程能提升 IO 读写的效率，从而整体提高 redis 的性能。 ↩

作者：后厂村村长
链接：https://www.jianshu.com/p/62b22cb8a6d0
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
