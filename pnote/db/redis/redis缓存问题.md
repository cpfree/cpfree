# 缓存相关问题

> <https://www.toutiao.com/a6533812974807679495>

### 缓存穿透、缓存击穿、缓存雪崩概念及解决方案

1. 缓存穿透(缓存命中率低)
   访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。
   解决方案
   采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
   访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。

2. 缓存雪崩
   大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
   解决方案
   可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

3. 缓存击穿
   一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。
   解决方案
   在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

### 缓存雪崩解决方案

1. 缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

2. 缓存设置过期时间设置到闲暇时刻, 之后闲暇时刻, 后台跑批更新缓存.

3. 两层缓存时间, 如实际缓存时间设置60分钟到期, 标记缓存时间设置为55分钟到期, 获取缓存后, 发现55分钟的到期了, 之后发送请求到专门更新缓存的线程去更新缓存.

4. 短时间内存存放缓存, 从redis里面查询到缓存后, 短时间内, 应用里面获取到的缓存不删除, 之后几分钟之内, 再进行查到这个缓存, 直接连redis都不进.

   缺点: 分布式应用之间可能造成短时间数据不一致问题.

### 缓存穿透解决方案

1. 布隆过滤器

2. 短时间缓存空值

   如果一个key查询不到, 就把这个值缓存起来, 那么在5分钟内再次查询这个key, 直接返回空.
   
   缺点: 分布式应用之间可能造成短时间数据不一致问题.

### 缓存击穿解决方案

1. 最简单的方式就是分布式锁.

   在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

2. 使用专门应用服务去从数据库获取缓存数据

   应用发现 redis 里面没有数据, 之后直接从`专门查询DB的服务`里面去取出数据, 不再去操作redis.
   
   专门查询DB的服务接收到相应之后, 阻塞全部请求, 对同一时间对同一个key的查询请求只去数据库进行一次key查询, 之后将数据更新到redis里面, 然后从服务中返回数据.
