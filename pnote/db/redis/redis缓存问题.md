# 缓存相关问题

> - <https://www.toutiao.com/a6533812974807679495>
> - <https://mp.weixin.qq.com/s?__biz=MzA4MjIyNTY0MQ==&mid=2647738927&idx=1&sn=4f37249616a29a9b97e6ed1d762b2663>

### 缓存遇到的问题

1. 缓存穿透(缓存命中率低)
   访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。

2. 缓存雪崩
   大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

3. 缓存击穿
   如果你的应用中有一些访问量很高的热点数据，当热点 KEY 在失效的瞬间，海量的请求会不会产生大量的数据库请求，从而导致数据库崩溃？
   一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

### 缓存穿透、缓存击穿、缓存雪崩解决方案

### 缓存雪崩解决方案

1. 缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

2. 后台跑批定时检查并更新缓存.

3. 两层缓存时间, 如实际缓存时间设置60分钟到期, 标记缓存时间设置为55分钟到期, 获取缓存后, 发现55分钟的到期了, 之后发送请求到专门更新缓存的线程去更新缓存.

4. 短时间内存存放缓存, 从redis里面查询到缓存后, 短时间内, 应用里面获取到的缓存不删除, 之后几分钟之内, 再进行查到这个缓存, 直接连redis都不进.

   缺点: 分布式应用之间可能造成短时间数据不一致问题.

### 缓存穿透解决方案

缓存穿透，有几种解决方案，一种是事前预防，一种是事后预防。

1. 参数效验
   可以设在 `redis查询的地方` 和 `网关入口`
   例如id是32位, 并且有规则, 如果不满足这些规则, 则直接不通过.

2. 布隆过滤器
   采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
   可以设在 `redis查询的地方` 和 `网关入口`

3. 短时间缓存空值

   如果一个key查询不到, 就把这个值缓存起来, 那么在5分钟内再次查询这个key, 直接返回空.
   
   缺点: 分布式应用之间可能造成短时间数据不一致问题.

### 缓存击穿解决方案

1. 分布式锁.

   在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

2. 永远不过期: 使用专门应用服务去从数据库获取缓存数据

   简单来说就是给数据库添加一个代理查询服务

   应用发现 redis 里面没有数据, 之后直接从`专门查询DB的服务`里面去取出数据, 不再去操作redis.
   
   专门查询DB的服务接收到相应之后, 阻塞全部请求, 对同一时间对同一个key的查询请求只去数据库进行一次key查询, 之后将数据更新到redis里面, 然后从服务中返回数据.

## 方案解析

### 分布式锁

分布式锁是万能方案, 但是会造成吞吐量低, 一般不推荐

分布式锁指的是在缓存 KEY 过期去更新的时候，先让程序去获取锁，只有获取到锁的线程才有资格去更新缓存 KEY。其他没有获取到锁的线程则休眠片刻之后再次去获取最新的缓存数据。

通过这种方式，同一时刻永远只有一个线程会去读取数据库，这样也就避免了海量数据库请求对于数据库的冲击。

而对于上面说到的锁，我们可以使用缓存提供的一些原则操作来完成。例如对于 redis 缓存来说，我们可以使用其 SETNX 命令来完成。

   ```java
   public String get(key) {
      String value = redis.get(key);
      if (value == null) { //缓存过期
         if (redis.setnx(key_mutex, 1, 1 ** 60) == 1) {
                  value = db.get(key);
                  redis.set(key, value, expireTime);
                  redis.del(key_mutex);
               } else {
                  //休眠片刻后重试
                  sleep(50);
                  get(key);
               }
         } else {
               return value;
      }
   }
   ```

上面的 key_mutex 其实就是一个普通的 KEY-VALUE 值，我们使用 setnx 命令去设置其值为 1。如果这时候已经有人在更新缓存 KEY 了，那么 setnx 命令会返回 0，表示设置失败。

### 永不过期

1. 后台开启额外线程, 或者是额外服务定期检查并更新key

2. 自动续期: 额外添加一个自动续期时间, 查询的时候判断下是否到了自动续期的时间, 若是到了续期时间, 则发送一个命令去更新key.

### 短时间缓存key

应用服务短时间缓存key和数据, 也是一个万能方案, 这个短时间可以设置随机值, 缓存key, 也可以结合bool过滤器使用

缺点: 短时间的数据不一致问题.
