---
keys: 
type: trim
url: <>
id: 220215-171456
---

# B 树索引

> 参考书籍: <mysql是怎样运行的>

## B + 树

innodb存储索引是一颗B+树, 完整的记录数据均存放在最底层的叶子节点中.

其它节点均属于内节点, 内节点存放的目录项记录

1. B+ 树一般来说最多不超过4层, 内节点中存放的均是目录项记录, 该记录很小, 一个内节点可以存放好多, 这是为了降低树的层数, 减少IO量.
2. B+ 树节点(数据页)之间以从小到大的顺序形成了一个双向列表, 数据页之内从小到大的顺序形成了一个分组的单向列表.

## innoDB

innoDB

innodb 索引分为两种

#### 聚簇索引

以主键值的大小作为页的排序规则, 在叶子节点存储的记录包含了表中所有的数据.

   聚簇索引的内节点目录记录内容: 主键值 + 页号
   聚簇索引的叶子节点记录内容: innodb数据页

#### 二级索引

以索引列的大小作为页和记录的排序规则, 在叶子节点存放的记录内容是索引列+主键.

   二级索引的内节点目录记录内容: 索引列的值 + 主键值 + 页号

   > 二级索引, 哪怕是唯一的二级索引, 也可能会出现多条记录键值相同的情况, 因此为了内节点的唯一性, 因此需要存放主键.

   二级索引的叶子节点记录内容: innodb数据页

查询的时候, 通过二级索引先查询到主键值, 之后再通过主键值, 到聚簇索引里面查询真实的数据.

#### 覆盖索引

指的是, 通过二级属性搜索主键, 因为主键就在二级索引里面, 因此没有必要再去回表查询了.

### 设置 unique 的字段是否可重复存 null 值

> 参考自: <https://www.jianshu.com/p/967f13140073>

unique 的列是可以重复存放NULL值的

同时, 不同分区内, unique的列还可以重复存入非NULL值.

```shell
### 非 NULL 值
# 1. 同一分区，重复的值  唯一键冲突
mysql> insert into yquk2(b,c) values('1','a'),('1','a');
ERROR 1062 (23000): Duplicate entry '1-a' for key 'uk_a'

# 2. 不同分区，重复的值  成功写入
mysql> insert into yquk2(b,c) values('1','a'),('2','a');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

### NULL 值, 无论是不是同一分区, 都可以重复写入
mysql> insert into yquk2(b,c) values('1',null),('1',null);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> insert into yquk2(b,c) values('1',null),('2',null);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

## myISAM

myisam 引擎将数据和索引分开存储.

myisam 将数据按照记录的方式直接按照插入的顺序存放到了一个数据文件中, 没有进行排序.

myisam 的索引也是B+树, 但是由于没有聚簇索引, 因此myisam里面建立的索引均是二级索引

myisam 索引, 叶子节点存放的是该条记录在数据文件中的地址偏移量.


## innodb 和 myisam

1. innodb 和 myisam 会自动为了主键或者带有unique属性的列建立索引




## 索引的代价

1. `IN` 产生的效果相当于, 对一条字段进行若干个等值比较`=`通过 `or` 连接起来.
2. `!=` 产生的效果近乎于全表扫描了, 例如 `a != 8`, 相当于扫描 `(-∞, 8)`  or  `(8, +∞)`.
3. `like` 例如 `like 'a%'`, 扫描范围是 `['a', 'b')`


不可以使用索引列排序的几种情况

1. 一张表里面, 对于同一个索引, 最好不要出现 ASC, 和 DESC混用的情况.
   mysql8 里面添加了一个 `DESCENDING INDEX` 可以支持 ASC 和DESC 的混用情况.

2. 排序包含非同一个索引的列

3. 联合索引中的排序列不在联合索引中连续.

4. 索引列和排序列不同

5. 排序列中的列不是单独字段出现在sql中

   如 `upper(key)` 是用不到key的索引的.

#### 更好的建立索引

1. 只为用于搜索, 排序或分组的列建立索引

2. 考虑索引列中不重复的个数.

3. 索引列的类型要尽可能地小
   `TINYINT < MEDIUMINT < INT < BIGINT`

4. 为列前缀建立索引
   如: 索引仅仅保持列的前10个字符, 为了降低索引的大小, 增加一个页存储索引的数量, 减少IO次数.

5. 覆盖索引

   优先使用覆盖索引进行查询.

6. 让索引列以列名的形式在搜索条件内单独出现

   mysql 没有那么智能, 如下

   ```sql
   -- key1 建立了索引
   -- 无法使用到索引
   select * from user where key1 * 2 < 4
   -- 可以使用到索引.
   select * from user where key1 < 4 / 2
   ```

7. 大批量新插入记录, 最好是按照主键的顺序.

   主键按照顺序插入, 在聚簇索引里面, 将数据插入到页的时候是插满一个页再插入另一个页
   但是如果不按照主键顺序插入, 那么插入的时候会导致各种`页分裂`的现象, 导致空间浪费不说, 还增加叶子节点数量.

8. 定位并删除表中的重复和冗余索引

   每建立一个索引, 都会建立一个B+ 树
   每对一个记录进行增删改, 都会导致去修改这个索引对应的b+ 树.

9. 使用联合索引的时候, 后面的列的顺序必须要和联合索引的顺序一致.
