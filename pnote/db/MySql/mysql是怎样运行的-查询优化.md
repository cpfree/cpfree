# 查询

## 单表访问方法

const | 通过主键定位一条记录
ref | 通过普通的二级索引列与参数进行等值比较.
ref_or_null | 普通的二级索引等值比较, 同时把 null 数据找出来.
range | 通过索引查询最终形成了扫描居间.
index | 联合索引中没有使用最左边的列进行查询, 使用了第二个列, 虽然是全表范围扫描, 但是在二级范围里面确实用到了索引
all | 全表扫描, 不解释.

### 单表单索引列索引合并

1. Intersection 索引合并
2. Union 索引合并
3. Sort-Union 索引合并

> mysql 没有 Sort-Intersection 索引合并, 但是 MariaDb 里面实现了交集排序索引合并.

mysql 支持 交集索引合并, 并集索引合并, 以及排序并集索引合并

## 连接原理

驱动表: join 连接确定的第一个查询的表
被驱动表: 从驱动表里面查询出数据后, 用查询出的数据, 都要到被驱动表里面去查询数据.

> 两表 join 连接, 驱动表只需要访问一次, 但是被驱动表需要访问多次.

### 内外链接

`WHERE` 过滤条件: 方式不匹配的都不会添加到结果中.

`ON` 过滤条件

1. 内连接中, `ON` 和 `WHERE` 过滤条件等同.
2. 外连接中, `ON`: 即便驱动表里面的数据被`ON`过滤掉了, 但是结果还是需要添加匹配不到的驱动表数据, 另外一张表的数据填充为 NULL
   - > 内连接中 `ON` 和 `WHERE` 是等价的, 因此在内连接中, JOIN 后面即便不使用 `ON`, 将原来`ON`里面条件移动到 WHERE 里面依然是可以查询出来的, 并且查询结果甚至 EXPLAIN 都和原来使用 ON 的时候一样, 但是为了 SQL 的可读性最好用一下.

### 嵌套循环连接

1. 之后从多个表中找寻两张表, 进行两张表连接, 得出临时表结果
2. 之后临时表和剩下的表再去判断谁是驱动表, 之后再连接, 重复该步骤, 知道最终查询出结果.

### 基于块的循环嵌套结构

假如说驱动表和被驱动表都很大, 数据量很多, 查询一次不容易

则可以:

1. 对驱动表做一次查询, 一次查询出驱动表里面的数据结果集.
2. 以块的形式IO出部分被驱动表, 之后每一条被驱动表里面的数据同时和多条驱动表里面的数据进行匹配.
   > 相当于对被驱动表进行一次全表扫描, 之后每一条记录和第一次查询出的驱动表里面的结果集进行比对.
3. 继续以块的形式读取, 重复2的步骤, 直到被驱动表IO一次.

## 查询优化-基于成本的优化.

1. IO成本
2. CPU成本

成本常数

   读取一个页面的成本是 `1.0`, 检测一条记录是否符合条件的成本是`0.2`

单表优化步骤

   1. 根据搜索条件, 找出所有可能用到的索引
   2. 计算全表扫描的代价
   3. 计算使用不同搜索引擎指定查询的代价
   4. 对比代价, 选出一个查询方案.

连接优化

   1. 选择最优的表连接顺序
   2. 为驱动表和被驱动表选择最优的访问方法.

## 查询优化-基于规则的优化.

1. 条件化简
   1. 移除不必要的括号
   2. 常量传递
      `a = 5 and b > a` 转换为 `a = 5 and b > 5`
   3. 移除没用的条件
   4. 表达式计算: 如果表达式只包含常量, 则直接计算出来.
   5. having 子句和 where 子句的合并
      如果查询语句中没有出现如 `SUM`, `MAX` 以及`GROUP BY`子句, 查询优化器就将having 子句和 where 子句合并起来.
   6. 常量表检测
      - 查询的表里面只有一条记录, 或者一条记录都没有.
      - 使用主键查询到语句
      > 这些查询很快, 可以忽略不记, 因此被称为常量表.

2. 外连接消除
3. 子查询优化

## EXPLAIN

### EXPLAIN-TYPE

1. system: 表中只有一条记录并且该表使用的存储引擎的统计数据是精确的

2. const 根据主键或者唯一二级索引与常数进行等值匹配
3. eq_ref: 执行连接查询时, 如果被驱动表是通过`主键`或者`不允许存储为 NULL 值的唯一二级索引列`以`等值匹配`的方式进行访问时.
4. ref: 当通过普通的二级索引列与常量进行等值匹配的方式查询某个表时.
5. fulltext: 全文索引
6. ref_or_null: 普通的二级索引等值比较, 同时把 null 数据找出来.
7. index_merge: 一般情况下会为单个索引生成扫描居间, 但是某些场景下使用intersection, union, Sort-Union合并索引时.
8. unique_subquery: 针对IN子查询, 决定将IN转换为EXISTS语句, 是的最后由`不允许存储为 NULL 值的唯一二级索引列`以`等值匹配`的方式进行访问时.
9. index_subquery: 与unique_subquery类似, 只不过, 最后不是唯一二级索引列, 而是普通索引.
10. range: 索引获取某些单点扫描居间的记录
11. index: 当可以使用索引覆盖, 但是需要扫描全部的索引记录的时候.
12. ALL: 全表扫描.