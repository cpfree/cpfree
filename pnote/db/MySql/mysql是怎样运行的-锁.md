---
keys: 
type: trim
url: <>
id: 220215-171345
---

# mysql-锁

> 参考书籍: <mysql是怎样运行的>

## 数据库并发问题

并发访问相同记录的情况大致分为下面几种情况

1. 写-写: 会造成脏写
2. 写-读: 会引起脏读
3. 读-写: 会引起不可重复读和欢度问题
4. 读-读: 不会有问题

### 写-写

写写会引起脏写, 脏写问题很严重, 任何一个隔离级别都需要处理掉脏写的问题.

简而言之就是多个未提交的事务相继针对一条记录进行改动,

针对一条记录进行加锁, mysql 里面加锁的方式就是每个事务针对一条记录生成一个 🔒 结构

锁结构有很多信息, 下面只挑选两个重要的

- trx 信息: 指向当前事务 ID
- is_waiting: 是否等待.

1. 针对一条记录操作的时候, 一个事务(A)在改动这条记录之前, 先生成一个锁结构, 之后去试图对这条数据获取锁, 获取成功, 则 `is_waiting` 设为 false, 表示加锁成功.

2. 之后, 在 A 没有提交之前, 其它的事务再去生成锁结构, 进行获取锁, 则会获取失败, `is_waiting` 设为 true 表示等待.

3. 之后等到 A 提交之后, 则会释放掉锁, 并唤醒一个在等待该条记录锁的事务.

### 读-写

读操作进行 MVCC 事务控制, 写操作进行加锁.

MVCC 通过生成 readView 的方式可以有效解决对未提交事务的读问题, 写操作也是在 readView 基础上去做的, 因此 MVCC 可以直接解决`写-读`问题.

### 写-读(会引起脏读)

读-写均使用加锁的方式

A 事务写入一条数据后, 在未提交之前, 不希望其它事务读取到该条数据, 直到最终 A 事务提交后, 或者是回滚后.

脏读的问题是, 如果一个事务写入了数据之后, 就为这个数据进行加锁, 在事务结束之前, 不允许其它事务进行读取, 那也就不会引起脏读了.

不可重复读: 如果一个事务读取数据的时候就为数据进行加锁操作, 那么也就不会出现不可重复读的问题了.

幻读: 一个数据通过某些条件搜索到了一些数据, 别的事物插入了符合条件的新数据, 之后再次读取, 就导致前后不一致, 这种情况没有办法为记录进行加锁, 因为插入的记录并不存在.

### 当前读 和 快照读

1. 当前读

   当前事务读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁.

2. 快照读

   MVCC 通过生成快照的方式使得之后的读取数据都是一致的, 因此 MVCC 读操作被称为`一致性读`, `一致性无锁读`, `快照读`等.

当前读就是悲观锁的具体功能实现

快照读就是 MySQL 为我们实现 MVCC 理想模型的其中一个具体非阻塞读功能。

> MySQL里面的innodb对MVCC的实现是以 `3 个隐式字段`，`undo log` ，`Read View` 协同完成的

## 数据库锁概念

1. 共享锁: 简称 S 锁, 事务读取到一条记录的时候, 需要首先获取到该条记录的共享锁.

2. 排他锁: 简称 X 锁, 事务改动一条记录的时候, 需要获取到该记录的 X 锁.

3. 意向共享锁: 简称 IS 锁, 事务为一条记录加 S 锁之前, 需要先为整个表加一个 IS 锁.

4. 意向排他锁: 简称 IX 锁, 事务为一条记录加 X 锁之前, 需要纤维整个表加一个 IX 锁.

第一个事务获取到一条记录的 S🔒 时, 其它事务依然可以获取该条记录的 S 🔒, 但是无法获取到该条记录的 X🔒.
第一个事务获取到一条记录的 X🔒 时, 其它事务既不能获取到 X🔒, 也不能获取到 S🔒.

### X, S, IS, IX之间的兼容性

X 与其它任何锁都不兼容
IS 锁与 IS, IX, S 锁均兼容
S 与 S 兼容
IX 与 IX 兼容
S 与 IX 不兼容.

## mysql 中的innodb中的锁实现

### mysql对 X, S, IS, IX的实现

mysql 实现了 X, S, IS, IX, 但事实上一般不会用到, 如下场景可以用到这些锁.

1.  在系统崩溃恢复的时候会用到这些锁.
2.  我们手动通过语句指定也可以使用这些锁.

   ```sql
   -- 对读取的记录加 S 锁
   select * from xxx lock in share mode;

   -- 对读取的数据加 X 锁
   select * from xxx for update;
   ```

### 行级锁(记录锁)

在记录上加的锁

mysql 上面的记录锁是有 S 锁和 X 锁之分的.

### GAP(间隙锁)

MYSQL 的 innodb 在`REPEATABLE READ`的时候就可以有效防止幻读, 原因有如下两个

1.  MVCC 解决方案
2.  GAP 锁

例如几行记录如下

| id  | name |
| --- | ---- |
| 1   | 小明 |
| 3   | 小花 |
| 8   | 小刘 |
| 15  | 小青 |

加入给`id=8`的记录加一个gap锁, 就可以直接方式`(3,8)`范围内被添加记录.

一个事务在插入的时候, 如插入id为4, 之后查询到`(3,8)`的位置, 首先需要定位到下一条记录, 也就是`8`, 看下上面是否有`GAP`锁, 有的话, 则阻塞.

GAP锁是为了防止插入`幻读`记录而设置的, `GAP`锁其自身是相互兼容的, 多个事务可以对同一条记录加`GAP`锁.

> 页里面有两条伪数据记录`Infinum` 和 `SupreNum`, 对于最后一条记录的间隙锁需要加到 `Suprenum` 上

### Next-Key Lock

既想锁住某个记录, 又不想其他事务在该锁中间插入新记录, 就可以插入一个 `Next-Key Lock`, 其本质是一个记录锁和Gap锁的合体.

### 插入意向锁

简而言之就是一个事务想要插入一条记录, 却发现后面一条记录上已经有了GAP锁, 因此只能等待, 但是在等待的时候也需要生成一个锁结构,

_大概是为了等GAP锁释放后, 唤醒该事务_, 

> 一般只有GAP锁会阻止插入意向锁, 插入意向锁之间不会相互阻塞.

### 隐式锁

一个事务插入一条记录后, 在未提交的时候, 另一个事务来读取或修改了, 就会造成脏读和脏写.

mysql里面的innodb中的隐藏列trx_id实际上就隐式的实现了锁的所用.

> 此时trx_id没有用在了MVCC里面, 而是用在了隐式锁里面.

因此, 一个事务插入一条记录的时候, 另外一个事务对该条数据进行修改, 根据trx_id判断下当前记录应不应该存在隐式锁, 若应该存在隐式锁, 则当前事务会生成一个锁结构, 之后进入等待状态.

> 此时实际上是没有加锁的, 但是隐藏列trx_id却起到了帮助其它事务加锁, 让其它事务陷入等待的作用.
