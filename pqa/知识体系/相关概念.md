# 名词解析

## 英文词汇

英文缩写 | 英文全称 | 含义
-|-|-
BOP | Bean Oriented Programming | 面向 Bean 的编程(Spring)
OOP | Object Oriented Programming | 面向对象编程
AOP | Aspect Oriented Programming | 面向切面编程
IOC | Inversion of Control | 控制反转
DI | Dependency Injection | 依赖注入
-|-|-
JPA | Java Persistence API |
JDO | Java Data Objects |
JMS | Java Messaging Service |
OXM | Object-to-XML-Mapping |
ORM | - | -
MOM | Message Oriented Middleware | 利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。
-|-|-
TPS | Transactions Per Second | 每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。
QPS | Queries Per Second | 每秒能处理的请求数目。
RPS | Requests Per Second | 每秒能处理的请求数目。

## 基本概念

1. 延迟加载 : 真正需要数据的时候才真正加载数据, 避免一些无谓的性能开销

## 理解I/O：随机和顺序

### POJO (Plain Old Java Object)

   POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，不具有任何特殊角色，和其他的java框架无关。

   > POJO可以认为是一个中间对象, 可以转化为PO、DTO、VO。
   >
   > 1. POJO持久化之后==〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）
   > 2. POJO传输过程中==〉DTO
   > 3. POJO用作表示层==〉VO

### JavaBean

   JavaBean实际上是指一种**特殊的Java类**，它通常一定编程原则，并可以很容易的被重用或者是插入其他应用程序中去。

   > 一般而言必须具有一个公共的(public)无参构造函数,所有属性私有化, public类型的方法（getter和setter）,可序列化

### 多线程

1. FIFO
2. 并发 & 并行 & 互斥 & 同步 & 异步 & 多线程
   - **并发** : 指应用能够 **交替执行** 不同的任务.并发又有 **伪并发** (单核处理器的并发)和 **真并发** (多核处理器的并发)。
   - **并行** : 指应用能够 **同时执行** 不同的任务.

相交进程之间的关系主要有两种，同步与互斥。

**互斥** ：进程间相互排斥的使用临界资源的现象，就叫互斥。所谓互斥，是指某一资源同一时间只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
**同步** ：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问.所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行.
**多线程**：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。
**同步** : 就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。
**异步**：异步就是彼此独立, 在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。
      异步和多线程并不是一个同等关系, 异步是最终目的, 多线程线程就是实现异步的一个方式。

**阻塞和非阻塞** : 就是看线程在进行获取资源或连接类似相关操作的时候会不会等待或轮询, 等待或轮询的话就是阻塞的, 直接返回的话就是非阻塞的.

线程安全的两个保障手段
      **阻塞同步** 和 **非阻塞同步** 都是实现线程安全的两个保障手段，非阻塞同步对于阻塞同步而言主要解决了阻塞同步中线程阻塞和唤醒带来的性能问题，那什么叫做非阻塞同步呢？在并发环境下，某个线程对共享变量先进行操作，如果没有其他线程争用共享数据那操作就成功；如果存在数据的争用冲突，那就才去补偿措施，比如不断的重试机制，直到成功为止，因为这种乐观的并发策略不需要把线程挂起，也就把这种同步操作称为非阻塞同步（操作和冲突检测具备原子性）。在硬件指令集的发展驱动下，使得 "操作和冲突检测" 这种看起来需要多次操作的行为只需要一条处理器指令便可以完成，这些指令中就包括非常著名的CAS指令（Compare-And-Swap比较并交换）。《深入理解Java虚拟机第二版.周志明》第十三章中这样描述关于CAS机制:

1. [NIO同步阻塞与同步非阻塞](https://blog.csdn.net/yswKnight/article/details/79347833)

BIO（同步阻塞式IO）
同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

NIO（同步非阻塞式IO）
同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

AIO（异步非阻塞式IO）
异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

BIO（IO）与NIO区别
其本质就是阻塞和非阻塞的区别

### ff

将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。

> i++原子操作分几步
AtomicInteger 如何实现增加的
[ThreadPoolExecutor](https://segmentfault.com/a/1190000015368896)

## 框架相关概念

### 框架的侵入性

一个框架的低入侵性, 就是说,想不使用这个框架的时候, 需要改的代码很少,因为这个框架可以通过配置xml ,properties文件等等 而单独发挥作用, 如果一个框架的高入侵性, 就是说, 如果突然不想使用这个框架, 那么需要改的代码特别多,因为 这个框架影响了整个代码编写, 到处都要使用它提供的方法, 其他代码对这个框架的方法 依赖性特别高.

### 轻量级框架和重量级框架

#### 轻量级框架

   1. 轻量级框架一般由struts，spring组成，侧重于减小开发的复杂度，相应的它的处理能力便有所减弱（如事务功能弱、不具备分布式处理能力），比较适 用于开发中小型企业应用.
   2. 轻量级框架是相对于重量级框架的一种设计模式：轻量级框架不带有侵略性API,对容器也没有依赖性,易于进行配置,易于通用,启动时间较短。这是轻量级框架相对于重量级框架的优势。
   3. 采用轻量框架一方面因为尽可能的采用基于POJOs的方法进行开发，使应用不依赖于任何容器，这可以提高开发调试效率；另一方面轻量级框架多数是开源项目，开源社区提供了良好的设计和许多快速构建工具以及大量现成可供参考的开源代码，这有利于项目的快速开发。

#### 重量级框架特点：

   1. 带有侵略性的API。
   2. 对容器的依赖。
   3. 提供固定的一组机能，不具有配置能力。
   4. 不同的产品，部署过程不同，不易通用。
   5. 启动时间长。

#### 轻量级框架和重量级框架的区别

   轻量级框架和重量级框架的区别在于解决问题的侧重点不同。
   轻量级框架侧重于减小开发的复杂度，相应的它的处理能力便有所减弱（如事务功能弱、不具备分布式处理能力），比较适用于开发中小型企业应用。
   重量级框架则强调高可伸缩性，适合与开发大型企业应用。 而轻量级框架采用POJO开发，重量级占用很大资源只是它们各自的特点，不能用来区分它们。
   轻量级框架不入侵就说不入侵是轻量级框架是片面的。
   我想，同样地，重量级框架占用资源多就说占用资源多是重量级也是片面的。