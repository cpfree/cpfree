# 项目幂等性设计

> 参考自: <http://blog.itpub.net/69969697/viewspace-2683852/>

幂等性通俗的就是: **任意多次执行所产生的影响均与一次执行的影响相同**.

## 需要幂等的情况

1. 前端重复提交, 例如网络延迟, 用户快速点击了多次.
2. 接口超时重试, 网络抖动或其他原因造成请求丢失，这样的接口一般都会设计成超时重试多次。
3. 消息重复消费：MQ消息中间件，消息重复消费。

## 幂等性实现方式

### 前端拦截请求

   - 前端发送请求之后, 按钮变灰
   - 同一请求发送做校验, 不能发送多次.

   > 前端幂等性处理, 能够拦截一些无意的操作, 但是无法拦截黑客的有意的攻击.

### 后端幂等性设计-状态机

很多业务是有一个业务流转状态的，每个状态都有前置状态和后置状态，以及最后的结束状态。

比如订单的状态有提交、待支付、已支付、取消、退款等等状态。

后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。

### 后端幂等性设计-ticket

前端每次的幂等操作都需要首先获取到后端返回的一个ticketId, 前端操作的时候需要将这个ticketId传到后端, 后端验证ticket成功后, 即刻将ticket失效, 就可以保证下一次同样的请求失败.

> 在网上看到token机制, 但我直接将其改成ticket了, 因为我觉得 token 应该是无状态的, 一次使用且有状态的应该是ticket.

![](https://gitee.com/cpfree/picture-warehouse/raw/master/pic1/1643032448570.png)

### 后端幂等性设计-序列号

每次前端操作均有序列号, 前端请求后, 后端对应的序列号 + 1, 同时让前端的序列号 + 1, 若序列号不对应, 则执行失败.

### 后端幂等性设计-唯一索引

利用数据库唯一索引

DELETE: 数据只能够被删除一次, 多次删除会删除失败, 自然是幂等的.
UPDATE: 同一条数据更新多次, 也没什么大不了
INSERT: 新增的请求中就带有索引, 这样新增一次后, 第二次也会失败的.
