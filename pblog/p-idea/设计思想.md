“All problems in computer science can be solved by another level of indirection(计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决)”。


破窗效应 ，是1982年 ，由美国政治学家威尔森和犯罪学家凯琳提出的 。它是指 ，如果有人打坏了一幢建筑的窗户玻璃 ，却没有人维修 ，经过的路人 ，就会像受到了暗示一样 ，被诱发打破更多的窗户 。然后 ，这个街区其他建筑的窗户 ，也可能被打破 。然后是其他街区 。其实这很好理解 。在干净的墙角 ，扔几张碎纸 。过几个小时后你再去看 ，那个地方多半就有了一小堆垃圾 。





破窗效应的本质就是对一些看似很小 ，但其实触及红线 、影响深远的效果错 。千万不能姑息 ，甚至要 "小题大做" 。对我们自己也很大的借鉴意义 ，比如打游戏 、刷短视频 ，在学习的时间经常因为这些娱乐导致挥霍一整天时间 。往往就是来自于内心的小玩一把放松一下 ，然后一发不可收拾 。


## 编程思想

### 原则（Principles）

DRY (Don't Repeat Yourself)
OCP (Open Close Principle)
SoC (Separation of Concerns)
IoC (Inversion of Control)
CoC (Configuration over Convention)
Indirection (Layering)

"Don't repeat yourself"很好理解。当你第二次写同样结构，变化不大的代码时，脑袋里就要闪现一个大大的问号：我是不是在repeat myself？如果是，就要重构，或封装，或抽象，或函数化，总之一个目的，消除重复。以笔者的经验，DRY原则看似基本，实则很多大型软件公司都未能做好，copy & paste到处可见。我们写代码，从一开始就要把握好这个原则，否则在「破窗理论」的指引下，代码的质量会快速划向万劫不复的深渊。

OCP原则是说「软件要对扩展开放，对修改封闭」。比如你写一个message dispatching的代码，如果你只用一个主函数去处理所有消息，那么，每加一个message type，你就需要修改这个函数使之能处理新的消息。正确的，使用了OCP原则的代码是每个消息都有自己的callback，主函数仅仅根据消息的类型找到对应callback，然后执行。这样，新加的任何消息都无需改动主处理函数。这就是「对扩展开放，对修改封闭」的一个最浅显的例子。软件开发中的很多手段，如继承，如Observer pattern（观察者模式）目的就是实现OCP原则。

以上两个原则是最基础最基础的原则，之后的原则都是在此基础上衍生出来的。

SoC听起来高大上，其实就是解耦，将复杂系统分治成不同的子系统，尽可能将变化控制在子系统中。如果你十多年前做过互联网，就知道那时的html混杂着语义和样式，牵一发而动全身；现在的网站html/css基本分离，上帝的归上帝，凯撒的归凯撒，各司其职。这就是SoC。另一个SoC的经典应用场景就是MVC design pattern —— 整个系统的逻辑被分成 Model，View，Controller三层，（理想状态下）其中一层的改动不会影响到另一层。

IoC原则的思想是"Don't call me, I'll call you"。这一原则促使软件产业从lib时代发展到framework时代。想想libc，里面有各种各样的函数供你驱使，整个控制权在你；再看看django这样的framework，你并没有整个系统的控制权，你只能被动地按照规范写出一个个函数或类，在必要的时候由framework调用。使用IoC原则的好处是高级的细节和逻辑被隐藏，开发者只需要关注business logic。比如说使用ChicagoBoss（erlang的一个 web framework）来写web app，你写的代码基本上是顺序的，并发（concurrency）无关的，但整个系统的执行是异步的，大量并发的。

CoC原则出自Rails（或者至少Rails将其发扬光大），它的意思是：为了简单起见，我们写代码按照一定的约定写（代码放在什么目录，用什么文件名，用什么类名等），这样省去了很多不必要的麻烦（但也不失flexibility，因为约定可以通过配置修改），比如说在ember里component的定义在controller里要CamelCase，在template里要用"-"。在django里，只要你在"app/management/commands"里写一个文件，继承BaseCommand类，就可以通过"./manage.py xxx"运行你的命令。

Indirection/Layering原则也是为了解耦，就是把系统分成不同的层次，严格规定层次间的调用关系。layering最著名的例子是ISO/OSI七层模型；indirection最著名的例子是hypervisor。软件领域最著名的一句话是："All problems in computer science can be solved by another level of indirection."

### 范式（Paradigms）

1. GP: Generic Programming(泛型编程)

   1. 算法被抽象出来与数据无关

2. MP: Meta Programming

   1. 程序代码做为其操作的数据来做编程，即用程序来生成程序
   2. 编绎时计算（将本来是在运行时做的运算提前到编绎时做）


### 方法论

主流的方法论不外乎三种：

OOP（Object Oriented Programming）
AOP（Aspect Oriented Programming）
FP（Functional Programming）

1. 面向过程编程 Procedure Oriented Programming(POP)
   实现目的：分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用。
   主要概念：方法、过程
   特性：模块化 流程化
   优点：性能比面向对象高, 因为类调用时需要实例化，开销比较大，比较消耗资源;
   单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
   缺点：没有面向对象易维护、易复用、易扩展

2. 面向对象编程 Object Oriented Programming(OOP)
   实现目的：由单个能够起到子程序作用的单元或对象组合而成。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。
   主要概念：对象、类、封装、继承、多态、消息传递、数据抽象、动态绑定
   
   特性：抽象 封装 继承 多态
   优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
   缺点：性能比面向过程低

3. 面向实现编程 Realize Oriented Programming(ROP基于OOP)
   实现目的：当我们要控制某个类的对象，那么我们会直接在当前程序（自身类）中，实例化该类，然后通过该类调用相应的方法。这是一种最基本的面向对象编程模式。
   主要概念：高耦合，不支持多态

4. 面向接口编程 Interface Oriented Programming(IOP基于OOP) 推荐
   实现目的：为了需求变更，接口层dll不用重新编译，只要编译实现层dll即可。调用接口的人会感到很舒服，接口依旧功能更新。适用于较不固定需求的项目。
   主要概念：低耦合，便于扩展

5. 面向切面编程 Aspect Oriented Programming(AOP)
   实现目的：针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。
   使用范围：切面、连接点、处理逻辑、切点、引进、目标类、代理类、插入

6. 面向数据编程（DOP）
   面向测试编程
   面向监控编程
   面向文档编程
   
7. 高内聚低耦合
   低耦合：实现接口与实现分离，结构清晰。
   高内聚：一个类中的属性方法都实现同一个业务

8. 函数式编程
   函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。

   主要思想: 把运算过程尽量写成一系列嵌套的函数调用。
   

面向过程与面向对象的区别

   面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；
   面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

   可以拿生活中的实例来理解面向过程与面向对象，例如五子棋。

   面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。

   如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

   可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。



