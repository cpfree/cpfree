# coding experience

## 代码书写感悟

1. 如果一个变量的定义是必须的, 同时业务逻辑比较复杂, 就统一放在方法上面去`声明`.

   ```java
   public Object functionDemo() {
      // 1. 变量检查
      // 2. 用到的变量定义(如果一个变量的定义是必须的, 就统一放在方法上面去定义)
      // 3. (可选) 定义lambda方法
      // 4. (可选) 处理掉特殊情况
      // 4. 逻辑
      // 5. (可选) 返回值检查
   }

   ```

2. 函数使用泛型的时候
   注意T和`Class<T>`之间的关系: 通过`Class<T>`可以转换为`T`, 但是通过T很难转换为`Class<T>`(虽然可以通过注解和反射通过T获取到`Class<T>`, 但这种方式不考虑)

   如果一个函数有`Class<T>`参数, 那么在调用的时候, `Class<T>` 是需要单独传入的对象, 那么在调用这个方法的时候就需要额外提供这个对象.

## 1. 父类或接口引用子类对象

> 依赖倒置原则,里氏转换原则

   ```java
   Map map = new HashMap<>();
   // ... 之后使用map操作
   ```

## 2. 早返回, 早排除掉情况

   ```java
   if () {
      return;
   }
   ```

## 3. 以通信的方式共享内存, 而不是以共享内存来通信

```java

public class A {

   private Object b;

   // 以共享内存来通信, 不要这样调用b
   public void func1() {
      System.out.println("正在使用b: " + b);
   }

   // 以通信的方式共享内存, 需要做到这样
   public void func2(Object b) {
      System.out.println("正在使用b: " + b);
   }

   // 可以考虑日志完全和变量区分开, 脱离业务逻辑
   public void func2(Object c) {
      System.out.println("正在使用: " + c);
   }

}

```

## 4. 异常处理准则

1. 尽量使用try-with-resource
2. 优先使用更加明确的异常, 尽量不要使用 RuntimeException, 
3. 在文档里面详细记录异常发生情况, 什么情况下会导致异常
4. 不要捕获 Throwable, 因为 Error 实现了 Throwable, 可以捕获 Exception
5. 一定不要忽略异常, 实在不行可以打印一个日志信息 this will never happen
6. 不要打印了日志后, 又将异常抛出, 这样会导致日志里面出现多条相同的异常信息
7. 抛出异常尽量将异常本身抛出, 即便通过异常包装异常, 也一定不要丢掉原本的异常信息.

## 5. 工具类写法准则

1. 工具类优先写成纯方法形式
2. 工具类尽量满足单一职责原则, 引起工具类变化的原因应该只有参数, 
3. 工具类, 尽量写完美, 通用, 要么就不要写成工具类的形式
   > 写代码一定要考虑后续的变动, 写一个完美通用的工具类有诸多好处, 但是如果不够通用, 那么就可能导致写很多个工具类, 而这些工具类未来可能会发生改变, 然后组合工具类又是一个大麻烦.
4. 工具类尽量脱离业务逻辑
5. 工具类尽量测试通过.




