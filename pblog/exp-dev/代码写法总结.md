# coding experience

## 代码书写感悟

1. 如果一个变量的定义是必须的, 同时业务逻辑比较复杂, 就统一放在方法上面去`声明`.

   ```java
   public Object functionDemo() {
      // 1. 变量检查
      // 2. 用到的变量定义(如果一个变量的定义是必须的, 就统一放在方法上面去定义)
      // 3. (可选) 定义lambda方法
      // 4. (可选) 处理掉特殊情况
      // 4. 逻辑
      // 5. (可选) 返回值检查
   }

   ```

2. 函数使用泛型的时候
   注意T和`Class<T>`之间的关系: 通过`Class<T>`可以转换为`T`, 但是通过T很难转换为`Class<T>`(虽然可以通过注解和反射通过T获取到`Class<T>`, 但这种方式不考虑)

   如果一个函数有`Class<T>`参数, 那么在调用的时候, `Class<T>` 是需要单独传入的对象, 那么在调用这个方法的时候就需要额外提供这个对象.

## 1. 父类或接口引用子类对象

> 依赖倒置原则,里氏转换原则

   ```java
   Map map = new HashMap<>();
   // ... 之后使用map操作
   ```

## 2. 早返回, 早排除掉情况

   ```java
   if () {
      return;
   }
   ```

## 3. 以通信的方式共享内存, 而不是以共享内存来通信

```java

public class A {

   private Object b;

   // 以共享内存来通信, 不要这样调用b
   public void func1() {
      System.out.println("正在使用b: " + b);
   }

   // 以通信的方式共享内存, 需要做到这样
   public void func2(Object b) {
      System.out.println("正在使用b: " + b);
   }

   // 可以考虑日志完全和变量区分开, 脱离业务逻辑
   public void func2(Object c) {
      System.out.println("正在使用: " + c);
   }

}

```

## 4. 异常处理准则

1. 尽量使用try-with-resource
2. 优先使用更加明确的异常, 尽量不要使用 RuntimeException, 
3. 在文档里面详细记录异常发生情况, 什么情况下会导致异常
4. 不要捕获 Throwable, 因为 Error 实现了 Throwable, 可以捕获 Exception
5. 一定不要忽略异常, 实在不行可以打印一个日志信息 this will never happen
6. 不要打印了日志后, 又将异常抛出, 这样会导致日志里面出现多条相同的异常信息
7. 抛出异常尽量将异常本身抛出, 即便通过异常包装异常, 也一定不要丢掉原本的异常信息.

## 5. 工具类写法准则

1. 工具类优先写成纯方法形式
2. 工具类尽量满足单一职责原则, 引起工具类变化的原因应该只有参数, 
3. 工具类, 尽量写完美, 通用, 要么就不要写成工具类的形式
   > 写代码一定要考虑后续的变动, 写一个完美通用的工具类有诸多好处, 但是如果不够通用, 那么就可能导致写很多个工具类, 而这些工具类未来可能会发生改变, 然后组合工具类又是一个大麻烦.
4. 工具类尽量脱离业务逻辑
5. 工具类尽量测试通过.

## 6. 代码分层

分层能很好的解耦合, 封装, 分模块, 分文件都有分层的作用.

不同层次的代码需要分开写, 例如业务代码和逻辑代码要分开, ui代码和后端代码要分开, 界面样式代码和界面行为代码要分开.

没错, 这样分开写很麻烦, 但是对于大中型项目是必不可少的, 一定要有一个写好的代码后续一定会被改动的思想在里在里面.

界面分层虽然很复杂, 但是后续有新的需求, 或者是出现了什么问题, 可以瞬间定位到问题, 应该是什么地方的代码出现了问题, 应该去修改什么地方的代码都可以很快找出来.

例如前端, html控制界面内容, css控制界面样式, js控制界面行为.
html是可以直接写样式的, 但是控制样式的功能弱, 而且难以维护, 需要css的帮组, 那不如将样式控制全权交给css去处理.
而js的功能更加强大, js可以控制界面的一切, 但是强大的js代码也是最难以维护的, js最好只控制界面行为.
然而很多情况下会出现这种情况, 那就是css的功能不够强大, 需要js的帮助来控制样式的变化, html显示等问题也需要js来加强功能, 这样不可避免的会使业务逻辑变得很复杂.
但事实上这种复杂的逻辑只需要很简单的方法便可以解决:

   例如利用状态模式和封装的思想,

当然如果是比较简单的工程(例如一个图书馆阅览功能), 并不需要考虑那么多, 但是事实上, 我们在开发的比较小的模块都应该实现确定好开发的模式和规范, 为了统一开发, 都应该这样做.

使用状态模式, 例如css样式抽出一些状态, 不同的状态展示不同的样式, html抽出一些状态, 不同状态展示不同内容. 这些状态统一由js来控制.

如果界面比较复杂, 或者是工程比较严谨, 那么直接加个中间层, 没有什么事情是加个中间层还解决不了的, 那么整个界面就变成了内容层(html), 样式层(css), 业务功能层(js), 交互层(js控制html和css的状态)

这种方式可以解决非常复杂的界面, 它有几种思想

1. 封装思想: 内容, 样式, 行为都在不同层里面, 它们是解耦的, 无法直接进行交互, 无需考虑对方怎么样.
2. 面向契约编程: 内容, 样式是需要被行为控制的, 但是行为不应该有太大的控制力, 样式和内容可以抽象出几种状态, 这些状态是向外暴漏的东西, 它们是向外暴漏的契约, 另外3层都应该依照这个契约进行编程.
3. 加个中间层: 没有什么事情是加个中间层还解决不了的, 这个地方加了交互层, 将另外三层变成了星形结构, 可以极大的代码的可读性和可维护性.



1. 中间层里面, js对css和html的状态进行控制, 或者是获取css和html的信息. 由于js是编程语言, 所以它可以往外暴露的不必再是状态, 他可以往外暴漏方法. **注意在这个地方只应该是行为控制内容和样式, 不应该有业务代码出现.**.
2. 业务功能层: 此处就可以写功能和逻辑了, 注意此处只写功能和逻辑, 千万不要再操作html和css, 否则整个封装就被破坏了, 如果想获取一个表单的信息, 可以将获取表单信息的逻辑变成一个方法, 放到交互层层里面, 之后再调用交互层去获取这个消息.
3. 最终的形式是, 业务功能层控制展示控制层, 展示控制层处理js, css, html之间的关系.
4. 如果程序员比较认真, 可以再注意一些问题, 例如, 在交互层里面往外暴漏的方法的时候, 可以将获取信息的方法和控制界面的方法分开, 或者取名字的时候区分一下, 为方法和变量取名字也是一门重要的规范, 业务逻辑层往外暴漏的方法中的参数和返回值, 应该都是些源数据, 不应该包含业务逻辑和太复杂的逻辑, 尽量只停留在和css以及html进行交互的层次, 例如不要在交互层获取数据的时候返回一个非常个性化的对象格式, 直接返回一个简单的json就行了, 也不要加太多筛选, 例如一个表单里面有10个值, 你需要其中5个, 那你直接写个方法把10个值全部获取了返回又能怎么用呢? 又能消耗多少CPU啊, 而且都是在前台也不怕数据的暴露.
