# tip

## bog

1. 扫描包下类文件的方法文档

## 知识

1. threadLocal可能引起内存泄漏原因

根据上一节的内存模型图我们可以知道，由于ThreadLocalMap是以弱引用的方式引用着ThreadLocal，换句话说，就是ThreadLocal是被ThreadLocalMap以弱引用的方式关联着，因此如果ThreadLocal没有被ThreadLocalMap以外的对象引用，则在下一次GC的时候，ThreadLocal实例就会被回收，那么此时ThreadLocalMap里的一组KV的K就是null了，因此在没有额外操作的情况下，此处的V便不会被外部访问到，而且只要Thread实例一直存在，Thread实例就强引用着ThreadLocalMap，因此ThreadLocalMap就不会被回收，那么这里K为null的V就一直占用着内存。

综上，发生内存泄露的条件是

1. ThreadLocal实例没有被外部强引用，比如我们假设在提交到线程池的task中实例化的ThreadLocal对象，当task结束时，ThreadLocal的强引用也就结束了
2. ThreadLocal实例被回收，但是在ThreadLocalMap中的V没有被任何清理机制有效清理
3. 当前Thread实例一直存在，则会一直强引用着ThreadLocalMap，也就是说ThreadLocalMap也不会被GC

## 懂技术体系, 还要懂业务体系

## 预生产环境的必要性和重要性

## 敬畏心

一个大型的项目, 任何一行代码其背后都有存在的价值, 正所谓存在即合理, 别人不会无缘无故这么写, 如果你觉得不合理, 那么就通过充分的调研和了解, 确定每一个参数背后存在的意义和设计变更, 以尽可能降低犯错的概率.

## 责任

自己的事情自己做, 不是自己的事情自己最好不要做, 否则一旦出现了问题, 背锅的可能就是你

## 一个简单的场景

## 内存泄露

一般而言, 内存泄露就是, 父类对象中有个内部对象, 之后, 父类对象被回收了, 子类对象却被其它对象强引用者, 导致回收不掉, 而且, 这个子类对象也一直没有用, 就造成了内存泄露.

## mysql 分页查询limit中偏移量offset过大导致性能问题

推荐分页

> select * form table limit 10000, 10
> 偏移量offset越大, 性能越低

推荐

1. 如果id是自增长序列, 那么可以

LIMIT分页查询时，索引是从0开始的，不是从1开始的
`select * from table where id >= 10000 limit 0, 10`

`select * from table where id > (select id from table limit 10000, 1) limit 10`

  从人正常的逻辑去考虑limit 偏移量去取数据的话大家可能会考虑到从100开始取，取三条数据，那我就直接跳过前一百条数据，然后取出后面三条数据。但实际上MySQL并不是这么做的，查看上面两图中可以看到当偏移量增大时，Sending data是耗时的主要原因，这是因为MySQL并没有那么智能，并非是跳过偏移量取后面的数据而是先把偏移量+要取得条数，然后再把偏移量这一段的数据抛弃掉再返回。关于优化的解决方案的话大致可以分为几条：

       1> 在业务允许的情况下限制页数：

        可以看看百度和谷歌的做法，百度搜索出来的结果集的话最大的分页数是76页，可以想到76页已经是一个足够大的页数了，哪里会有人在那里一直翻页翻到76页，而谷歌更狠，我所查到的谷歌搜索结果集最大页数是28页，而且谷歌搜索出来的页数和百度不一样的是谷歌并非将页数定死的。

在大的数据量面前使用where id>offset 来代替使用limit offset：

假如说如果真的要物理删除，那解决方法的话就只能先取出前offset条数据的ID，再去做偏移取数据

## 多线程并发代码

```java
ExecutorService executor = Executors.newFixedThreadPool(threadNum);

log.info("开启了 {} 线程", threadNum);
for (RicTypeMapping typeMapping : ricTypeMappings) {
   executor.submit(new MultiThreadCall(typeMapping, cnt));
}
executor.shutdown();
log.info("executor.shutdown");
while (true) {
   try {
         if (executor.awaitTermination(1, TimeUnit.SECONDS)) {
            // 线程池结束时调用
            break;
         }
   } catch (InterruptedException e) {
         e.printStackTrace();
   }
}
```

## @FunctionalInterface

@FunctionalInterface 就是用来指定某个接口必须是函数式接口，所以 @FunInterface 只能修饰接口，不能修饰其它程序元素。
@FunctionalInterface 注解主要是帮助程序员避免一些低级错误，例如，在上面的 FunInterface 接口中再增加一个抽象方法 abc()，编译程序时将出现如下错误提示：
"@FunctionInterface"批注无效；FunInterface不是functional接口

 Java8提倡函数式变成，因而新增了一个函数式接口。函数式接口保证了函数式编程，同时也保证了能够兼容以前的java版本。

     函数式接口的定义

     在java8中，满足下面任意一个条件的接口都是函数式接口：

1、被@FunctionalInterface注释的接口，满足@FunctionalInterface注释的约束。

2、没有被@FunctionalInterface注释的接口，但是满足@FunctionalInterface注释的约束

     @FunctionalInterface注释的约束：

1、接口有且只能有个一个抽象方法，只有方法定义，没有方法体

2、在接口中覆写Object类中的public方法，不算是函数式接口的方法。

## 目前有个表，专门记录日志的，假定我的表id为int类型，现在不考虑表查询新能和能存储多少数据。id自增到了int类型所能表达的最大值的时候，id还会自增吗？

当自增值已经达到最大值的时候，InnoDB存储的AUTO_INCREMENT值不再增加，下次获取的值还是4294967295，出现主键冲突。

## static类、static变量会不会被GC回收

1)静态变量本身不会被回收

2)静态变量所引用的对象是可以回收的。
static final 对象不会被回收

1、不要毫无计划地写代码，思考、调研、计划、编码、测试、修改，一个都不能少；

4、使用实现功能的最简单方案，作为专业的程序员，你的职责不是找出问题的一个解决方案，而是找出问题的最简单的解决方案；

12、一定要写好测试，如果可能的话，甚至在开始写代码实现需求之前，你就应该开始预估和设计需要测试校验的情况了。测试驱动开发 （Testing-driven development, TDD）不是什么花俏的炒作，它是会实实在在会对你思考功能特性、寻找更好的设计方案产生积极影响的。

16、不要过度迷恋性能优化，如果你在运行代码之前就在优化它了，那很可能你就是在过早优化代码了，也很可能你正在费时费力做的优化是完全没必要的。

17、以用户体验为目标，要站在最终用户的角度看问题。专业的开发者要考虑这个特定功能的用户需要什么、怎样使用，要想方设法使得这个功能容易让用户发现和使用，而不是想方设法在应用中用最便捷添加这个功能，毫不考虑这个功能的可发现性和可用性。

20、切勿重复造轮子，使用好现有的轮子和各种开源库，会让你事半功倍。当然，不要仅仅为了使用一两个函数就引入一整个代码库，在 JavaScript 中的典型例子就是 lodash 代码库；

22、用好版本控制工具和系统，新手往往低估了一个好的版本控制系统的威力，我这里所说的好的版本控制系统其实就是指 Git；


## 关于配置

> 之前一个超时设置, 找了好久没有找到, 最后发现写死在代码里面了, 类似于超时设置一定要写在最外面配置里面, 统一配置, 如果在最外面觉得麻烦可以找点其他方法. 但是一定要统一管理和简单配置.













## 一个类或者一个代码文件不应该过大

超过600行, 如果过大, 则应该将类分成多个类, 但是在分类的时候, 应该按照严格的逻辑进行分类, 使得: 在查找某个方法的时候, 可以根据类名直接能判断出要找的方法就在类中, 否则还不如不拆分大文件.
















成人学习相比于学院学习是不一样的

成人学习不同于学校考试的学习，它是以实用为主。讲究尽快学会，学过来就能运用，然后再以问题导向的，解决问题来提升能力的学习。而不是学校里，从底层的原理，知识点，再推导公式……慢慢一点点打基础，一步一步的来。

举一个简单的例子。比如我们要学习如何做牛排，我们不会去分析各个牛肉位置的口感，切牛肉的刀有哪几种，有几种切法……我们只是很简单按照步骤，做出牛排来就好了。这样的学习，进步非常快。

有的人就怀疑没有基础！但是人学习的时候，非得学校里面从底层知识一步步学起？我们刚学习走路时候，难道还要先学万有引力定律？那么我们学得头晕脑胀都学不会走路。而在你苦苦学习走路需要的公式时候，人家不仅会走，还会跑，还会跳……

我上班最开始学习编程时就犯了这样的错误。编程么，从最原始的电脑是如何开始形成的，然后一步步的学习，由机械化如何进入到电子的，又是什么图灵……学了很久，看了很多复杂的书籍，然后过了几个月我也都没有学会编一个“hello world”的小程序。要是我能够直接照着编程书籍，先编几个小程序就是了。管它狗屁历史，狗屁基础，什么底层原理，那么我早就学会了。不会导致到现在都对编程持一个很难的感觉。

故一定要明确，成年人学习与学校学习的区别，我们要以实用为主，尽快的学会，并以问题导向的学习。




真正的学习必然会让人有些痛苦的事情。

工作后，再也不能跟上学时一样，什么都看，什么都学，甚至把娱乐当学习。必须要有侧重性地先提升能力。若是要消遣娱乐当然可以看些杂书，但是不要称其为学习。

学习有两种类型，一种是知识的学习，一种是能力的学习。工作后，我们以提升技能、能力为主，把知识转化为能力。

工作后，我们会遇到很多问题，需要大量学习与工作相关的知识、技能，来迅速适应我们的工作，这是最直接提升我们经济收入的方法。

一边工作，一边建立我们的能力库。把问题看作是工作能力的需求，我们要建立起相应的能力。

大的技能都需要一些小技能的结合。把大技能拆成小技能，集中学习，突破小技能，一点点的掌握大的技能。形成能力，运用能力来解决问题，创造财富。



2.运用知识，转化为能力。
学了就用。学最需要的技能，学习后就能够直接运用上，解决问题，创造价值。

请问你学习了知识，去运用了吗？很多时候，我们都只是学了知识，以为自己掌握了。其实脑子里的知识转化为行为的知识，这之间差了一个运用的距离。

检验我们是否掌握了知识，判断的标准就是看我们是否能随时随地运用知识。

我曾经出于兴趣学习了很多的生活技巧，比如如何整理房间，如何尽快入眠……但是结果呢，我还是住在一个乱糟糟没有整理过的房间里。还是很长的时间都没有早睡休息。这其实就是根本就没掌握这些知识。

经常听到别人说，明明懂了很多的道理，但是为什么依然没有过好这一生？原因就是因为根本就没有懂得。

若是真得懂了，真的掌握了，又怎么会放弃那巨大的好处，不去按照知识、方法做事？

给你一万亿，给你好多大美女来爱你，但是条件是让你要早睡早起。那么定然你九点不到就去睡觉去了，起床起的比闹铃还准时。


3.技能的提升与进步
这里就是精进技能，我们掌握了技能，想要提升，就得要精深挖掘。

生活里面，我们确实见到有的人能够几十年时间都没有啥子进步。楼下的臭棋篓子的老头儿，天天凑一块下象棋，但是他们下了那么长时间依然吹胡子瞪眼嚷着要悔棋。

我就经常会担心，我的写作水平能不能有进步呢？或者多少年后，我能否成为一名真正的作家？

关于技能的提升，公认的方法就是“刻意练习”。提升专注度啊，重复练习啊……

但是对于成人来说，最好的方法还是解决问题。遇到问题，解决问题，技能就提升了，就这样。

阿里云技术团队的蔡景现，作为淘宝最早的程序员之一，淘宝网很多产品在早期就是他一个人开发维护，包括文件系统 tfs、key-value 系统 tair，cache、搜索、通讯框架等等。
在程序师眼中，他就是个神，一人能顶一个团队。从 03 年到 07 年，淘宝搜索引擎就是他一个人在写，一个人在维护，而且这还不是他全部的工作，另外他还做了其他很多事情。最可怕的是，蔡景现根本不是什么计算机专业出身，他学的是生物系生命科学专业！
这么牛逼的人如何成长为大神？他的回答就是“解决问题”。

所以千万不要再害怕会遇到麻烦了，把工作的问题，当作提升能力的方法吧。






4.反思经验，提升成理论
反思与复盘是非常快的提升能力方法。

一个做反思的人，他的进步可以是别人进步的十倍。成甲工作后，提升速度特别快，一年就拥有了别人十几年的经验了。原因就是每次做事都喜欢复盘，做总结。后来还成了《得到》王牌合作者。

把工作的经验提炼成理论，再用理论来指导自己的工作。

5.忘记知识
我说了这么多，蛮长的一篇文章，看着也挺麻烦的。但是，最高级别的学习是忘记了这些知识。

你已经忘记了自己会这些知识、理论。然后生活中虽然没有意识到你已经掌握了，但你又能无时无刻运用着这些知识。这就是所谓的学习知识的内化，已经变成你的一部分。你已经进化了。

人是能够真实发生改变的。那些真实的蜕变是会让人惊艳的。




----End----











为下属分配工作, 一定要确保下属的工作可以做, 如何下属的工作不好做, 那么下属在工作的时候, 效率也不会太高, 

你可以让下属帮你做很多事情, 但是你一定要了解下属做的东西, 你需要保证下属离职后, 后续依然会有人继续做这些事情.

领导和员工的步伐一定要保持一致, 如果长期不一致, 那么慢的那个应该及时被淘汰, 领导和员工步伐保持一致可能很难, 但是可以添加一个中间计划, 指定一个计划, 领导和员工都去和计划保持一致.

一件事情快速完成并产出成果未必是件好事, 但是绝大多数领导只看最终的成果, 即便是饮鸩止渴的行为, 领导也未必看得到, 作为最高级领导一定要看长远, 也一定要看到那些看的比较长远的员工, 它们能做出优质的东西.

作为员工, 若领导看不到太远的事物, 也没有必要太过在意饮鸩止渴的行为, 可以一边提升自己, 一般决定跳槽, 换个领导.
















数据库数据对比方案

1. 








开发时实现做详细的设计好, 还是一边设计一边开发好

1. 直接开发可能会遇到各种各样的问题, 导致最终走很多弯路

2. 事先做详细的设计缺点

   1. 比较浪费时间, 
   2. 且考虑的事物太多, 导致考虑的比较复杂
   3. 并且有些事情考虑不到, 

事先可以先对整个流程做一个简单的规划, 注意一定要完整的做完整个流程.

之后进行开发和调研(可以做一个文字流程, 写一个伪代码), 消除一些不确定的东西, 这样的话, 设计的时候也会变得简单

之后一边设计一边开发, 设计的时候开发, 开发的时候及时更改设计文档

可以考虑先做一个最简单的项目, 但是注意一定要保证扩展性, 后续再逐渐增加功能.



1. 消除一些不确定的东






面试时面试官不会看你搞了什么, 你需要实现直到面试官需要什么样的人, 尽量简单高效的满足面试官的需求.

