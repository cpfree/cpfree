# 单点登录解决方案

## CAS

后端需要 session 保存登陆状态.

1. 单点登录


2. 单点登出


## JWT

1. 后端不需要session 保存登录状态, 可以有效避免前端跨域问题.
2. 后端需要保存登出状态.

1. 单点登录设计

   参考, JWT 原理

2. 单点登出设计

   简单来说就是需要使 token 失效.

   适用场景: 
      1. 需要踢人
      2. 用户点击单点登录

JWT 和网关进行组合使用

   1. 首先用户登录 sso 账户系统, 获取一个access token 和一个 fresh token.

   2. 用户访问其它系统, 先访问网关, 网关对 access token 进行解析, 解析成功的话放到头里面, 转发给对应的服务.

配合单点登出

   第二步, 对JWT解析成功后, 改成还需要判断下爱用户是否需要被踢出. 也就是说token是否应该有效.

   当其他应用需要踢出该用户, 或者是该用户登出了, 那么应用需要让网关知道该用户的token需要失效了, (这个通过直接发送MQ消息给网关或者是使用redis共享内存均可以).

内存分析

   此时, 网关或者是redis内存, 只需要保存的是需要失效的token, 这个内存占用不会太大, 而且由于token是有过期时间的, 假如token失效时间设为1小时, 那么只需要内存中最多只需要保存这些数据一个小时就可以.



## 让token失效的解决方案

### 和网关共享失效的token设计

当应用需要让token失效的时候, 只需要发送信息给网关, 让网关在验证token的时候知道token已经失效了.

   此时网关验证token的步骤有两步
   1. 验证token本身是否有效.
   2. 验证token是否被失效(验证token是否在失效列表里面)

共享信息方式

   1. 应用发送token失效消息给网关, 由网关存放信息.
      好处: 网关在获取信息的时候随时可用.

   2. 使用共享内存, 如redis, 网关每次判断token时需要访问redis.
      好处: 使用共享内存, 便于统一和维护.

   > 以上方式可以灵活选择.

失效方式

   失效方式一般为管理员`踢人`, `单点登出`和用户的`二次登录`, 主要分为下面两种情况.

   1. (踢人, 单点登出)直接让用户之前所有的token失效.
      此时需要和网关共享的消息包括
      - 用户id: 用于指定用户
      - 当前消息失效时间: 如果当前共享信息存在redis里面的话, 通过该属性判断该条信息在redis里面需要保留多久, 如果是access_token, 并且access_token一般有效时间小于10分钟, 那么该失效时间就设置为10分钟就好了.
      - 当前时间: 用于判断, 凡是token生成时间小于当前时间的都失效掉.

   2. (二次登录)用户生成新的token后, 让旧的token失效.
      - 用户id: 用于指定用户
      - 当前消息失效时间: 如果当前共享信息存在redis里面的话, 通过该属性判断该条信息在redis里面需要保留多久, 如果是access_token, 并且access_token一般有效时间小于10分钟, 那么该失效时间就设置为10分钟就好了.
      - 新的 token 生成时间, 

综合来看共享信息需要包含3部分

   1. 用户ID: 用来指定用户
   2. 当前信息失效时间: 存放的时间至少需要晚于token失效的时间. 过期时间到了之后, 就可以从内存里面删除这些信息.
   3. token有效时间线: 如果验证token的时候发现token的生成时间小于当前时间线, 则表示当前token已经失效, 该属性和用户id结合起来可以保证一个用户一个时间内最多只有一个token是有效的.
      如果没有该属性, 那么用户在短时间内重复登录登出, 那么期间所有的token信息, 用户均需要存储, 那么内存里面需要存放大量的失效token的信息.

   实际上如果登陆的access有效时间都是一样的例如 `60` 分钟, 那么只要`有效时间线`或者是`当前信息失效时间`就可以了, 因为`当前信息失效时间`可以通过`有效时间` + `60分钟` 算出来.

   如果想保守一点: 那么可以再添加个`tokenId` 如果有的话.

   为了减少内存的占用, 可以采用 userid 做key, 其它的信息用一个字符串连接起来, 如果还嫌大, 再压缩一下.数字转成64进制.

#### 其它设计

1. 用户生成token后, 就将token存放到session里或共享内存里面

   优点: 额...简单, 小白
      1. 如果信息量比较大的话, 至少可以一部分大信息存到token里面, 在session里面只需要存储少量信息.
      2. 如果是网站使用率频繁, 如交易员每天使用的交易系统, 那么该方法也不是不可行
   缺点: 
      1. token 变成了有状态的东西.
      2. JWT优势没有利用.
      3. 后台需要大量内存存放token标记.

### 重新生成token设计

当服务端在检查到请求的令牌过期之后，会刷新Token重新颁发令牌，并且再次做登录操作，看似平静友好无感知，但试想一下，在页面加载后倘若同一个页面中有多个请求几乎同一时间发起，每一个请求都携带原始令牌，在这样的设计下，就有可能出现在第一个请求到达后刷新了Token，并更改了缓存中的refreshToken的时间戳，以至于剩余请求校验时发现时间戳不一致导致验证失败而在日志中多次打印出当前Token已经失效的log。同时发起的请求越多，log中的异常也就会越多。虽然第一个请求已经刷新了Token，但是其余的请求是失败的，页面中的数据并不完整，显然这是不正常的，那该如何解决呢？

方案一: 

   如果旧令牌还没有过期(只要此次没有过期, 哪怕判定完1秒后就失效), 并且是正常触发token刷新的话, 生成新令牌后, 旧令牌延迟10秒失效, 此时10秒之内, 新旧令牌均有效, 10秒之后, 让旧令牌失效.

   一个好的模式是在它过期之前刷新令牌。前端定时, 或在令牌即将失效的时候, 调用服务端去刷新令牌, 

   如果旧令牌过期了, 那还刷新毛的令牌啊, Token过期，直接重新登陆吧!

   即便是access token 过期了, 也直接重新登陆(将其视为一种不容易发生的情况, 失效之前就应该去刷新令牌.)

   多个请求同时到达的时候, 仅仅允许一个请求通过, 其它的请求进入等待状态.
