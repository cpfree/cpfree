---
keys: SSO
type: copy,blog,trim
url: <>
id: 220110-140445
---
# 单点登录

> [https://www.jianshu.com/p/75edcc05acfd](https://www.jianshu.com/p/75edcc05acfd)


随着企业的发展，用到的系统随之增多，进入不同的系统时，需要多次登录，而且每个系统的账号还都不一样，这很不方便。

于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。

单点登录英文全称Single Sign On，简称就是SSO。它的解释是：**在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。**

# 技术实现

在说单点登录（SSO）的技术实现之前，我们先说一说普通的登录认证机制。

![](//upload-images.jianshu.io/upload_images/12540413-8cfaf1ba9956573f.png?imageMogr2/auto-orient/strip|imageView2/2/w/578/format/webp)

image

如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。

## 同域下的单点登录

一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。

我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：

* Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。
* sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。

![](//upload-images.jianshu.io/upload_images/12540413-ddff3256817e357b.png?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp)

image

那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。**我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。**

Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。

同域下的单点登录就实现了，**但这还不是真正的单点登录。**

## 不同域下的单点登录

同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？

这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。

![](//upload-images.jianshu.io/upload_images/12540413-041b3228c5e865e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

cas_flow_diagram

上图是CAS官网上的标准流程，具体流程如下：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。


# 总结

单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：

* **单点登录（SSO系统）是保障各业务系统的用户资源的安全 。**
* **各个业务系统获得的信息是，这个用户能不能访问我的资源。**
* **单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。**

作者：牛初九
链接：https://www.jianshu.com/p/75edcc05acfd
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 问题

1. 单点退出如何实现让全部子系统都退出.

   1. 单点退出后, 后台让所有系统的session失效就可以了, session失效,cookie也就全部失效了.
      1. 通过MQ异步消息的形式让session失效
      2. 服务端的凭证存到 Redis 中, 让redis里面的数据失效.

2. 用户A 没有安全退出, 此时B用户登录了

   1. 还有一个场景是A系统登录了，B系统也登录了，这时候 A 系统退出登录重定向至 SSO 登录，并切换了一个用户登录，然后 B 系统本地还是 老的 cookie，然后验证的时候服务器返回了登录失效错误码重定向了SSO, SSO系统查看已经登录了, 之后为APP2生成一个ticket
      1. A cookie 失效重定向sso，sso已经登录B了携带B的信息跳转回来就登录B了.

   **有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？**

   **其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。**



3. 既然有CAS了，为什么APP1和APP2需要让Browser去CAS鉴权呢？APP1直接访问CAS鉴权不更安全，APP1和APP2压根就不应该支持Browser的访问才对.

   Browser去CAS不是去鉴权, 而是去要ST票据

   1. CAS为Browser发送票据, Browser通过票据到 APP1, APP1根据票据验证Brower的身份, 同时同步下信息(获取session, 用户信息, 同步session期限之类的).
   2. 一个票据只能用一次, 无论 Service Ticket 验证是否成功， CAS Server 都会清除服务端缓存中的该Ticket ，从而可以确保一个 Service Ticket 不被使用两次。
   3. ST 在一段时间内失效, 默认有效时间为 5 分钟.
   4. ST 是基于随机数生成的, 必须足够随机，如果 ST 生成规则被猜出， Hacker 就等于绕过 CAS 认证，直接访问 对应的服务。

   如果没有票据的话, 那岂不是需要拿 CASTGC 去验证, 弊端如下

   1. CASTGC 可以永久使用了. 堪比一个万用卡.
   2. CASTGC 不容易变, 而且多次使用, 易于被拦截获取.
   3. 不易控制.





4. x用户登录了A, B 系统, 之后没有退出, 之后清除掉, A域名和SSO的cookie, 重新登陆页面, y用户直接重新登录了一次.
   1. 此时后台该如何判断 用户x已经退出了?
   2. 此时打开B系统是不是还是x用户呢?


5. 关键在于ST这个凭证在不同域名系统间如何传递呢？如果还是cookie,localStorage之类的，就又回到最初的问题上了吧，所以，如何保存ST?“直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢”。如果st是加密的是不是就不存在这个问题了。不过就是要在所有业务系统中解密。但是去sso系统认证st是否合法，也涉及加解密了吧。
6. emmm，楼主，如果cookie被禁用的话，那怎么办？把ST这种类似于sessionId的东西直接加在url里面嘛？


A网址在SSO认证通过了，SSO有token了，这时候B网址初始化刚进来的时候肯定要和SSO通信一次的，看有没有token，这里建议使用iframe + postMessage 进行跨域实时通信，退出的逻辑也是一样的



用户在SSO登录成功后，会写一个TGT的cookie到sso的域名下。 当用户访问app2时，app2会重定向到sso的域名，这是TGT这个cookie就会带上。sso就能从session中拿到用户信息，发放给app2一个service ticket即可。app2可以根据这个st来获取用户信息



票据发送给系统1的时候,不是会再次请求sso那时候同步过期时间不久OK了,除非你长时间逗留到超过有效时间.

**回复**


楼主，关于app2系统登录场景的描述：
1、用户访问app2系统，app2系统没有登录，跳转到SSO。
2、由于SSO已经登录了，不需要重新登录认证。
这块第2个步骤有个问题，假如有多个用户都在登录app2，按你说的1、2步骤往下走，SSO如何判断对应哪个用户已经登录了，此时多个用户在app2系统的session都还不存在吧，SSO如何对多个用户进行一一对应的？因为你第5步骤才写入该用户在app2域下的cookie，所以刚开始访问app2时不会携带cookie的。



emmm，楼主，如果cookie被禁用的话，那怎么办？把ST这种类似于sessionId的东西直接加在url里面嘛？
如果加在里面，其他没有登录的人用这个url不也可以登陆上去了嘛，那这样算起来还要加上浏览器的独特的，类似于mac地址这种信息嘛？




楼主，用户在app1完成登录了，再从app2登录时SSO不再进行登录认证了，但cookie是不共享的，那SSO是依据什么判断登录app1和app2的是同一个用户呢？

sso的cookie呀

[@牛初九](https://www.jianshu.com/u/e94a2d9331d2) 新版本谷歌浏览器A域内访问B域的url地址时已经禁止携带Cookie了

用户在SSO登录成功后，会写一个TGT的cookie到sso的域名下。 当用户访问app2时，app2会重定向到sso的域名，这是TGT这个cookie就会带上。sso就能从session中拿到用户信息，发放给app2一个service ticket即可。app2可以根据这个st来获取用户信息
